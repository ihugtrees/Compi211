;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 71

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(-1,1)
MAKE_LITERAL_PAIR(const_tbl+1,const_tbl+1)
MAKE_LITERAL_RATIONAL(2,1)
MAKE_LITERAL_RATIONAL(3,1)
MAKE_LITERAL_RATIONAL(4,1)
MAKE_LITERAL_RATIONAL(5,1)
MAKE_LITERAL_RATIONAL(6,1)
MAKE_LITERAL_RATIONAL(7,1)
MAKE_LITERAL_RATIONAL(8,1)
MAKE_LITERAL_RATIONAL(9,1)
MAKE_LITERAL_RATIONAL(10,1)
MAKE_LITERAL_RATIONAL(11,1)
MAKE_LITERAL_RATIONAL(12,1)
MAKE_LITERAL_RATIONAL(13,1)
MAKE_LITERAL_RATIONAL(14,1)
MAKE_LITERAL_RATIONAL(15,1)
MAKE_LITERAL_RATIONAL(16,1)
MAKE_LITERAL_RATIONAL(17,1)
MAKE_LITERAL_RATIONAL(18,1)
MAKE_LITERAL_RATIONAL(19,1)
MAKE_LITERAL_RATIONAL(20,1)
MAKE_LITERAL_RATIONAL(21,1)
MAKE_LITERAL_RATIONAL(22,1)
MAKE_LITERAL_RATIONAL(23,1)
MAKE_LITERAL_RATIONAL(24,1)
MAKE_LITERAL_RATIONAL(25,1)
MAKE_LITERAL_RATIONAL(26,1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+ WORD_SIZE*0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+ WORD_SIZE*1], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+ WORD_SIZE*2], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+ WORD_SIZE*3], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+ WORD_SIZE*4], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+ WORD_SIZE*5], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+ WORD_SIZE*6], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+ WORD_SIZE*7], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+ WORD_SIZE*8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+ WORD_SIZE*9], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+ WORD_SIZE*10], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+ WORD_SIZE*11], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+ WORD_SIZE*12], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+ WORD_SIZE*13], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+ WORD_SIZE*14], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+ WORD_SIZE*15], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+ WORD_SIZE*16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+ WORD_SIZE*17], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+ WORD_SIZE*18], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+ WORD_SIZE*19], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+ WORD_SIZE*20], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+ WORD_SIZE*21], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+ WORD_SIZE*22], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+ WORD_SIZE*23], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+ WORD_SIZE*24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+ WORD_SIZE*25], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+ WORD_SIZE*26], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+ WORD_SIZE*27], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+ WORD_SIZE*28], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+ WORD_SIZE*29], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+ WORD_SIZE*30], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+ WORD_SIZE*31], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;def map
;applic   lambda (null? car cdr cons apply):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:cons to box  VarParam:cons, set  VarParam:apply to box  VarParam:apply,applicTP   lambda (map-many map-one):seq:   set  VarParam:map-many to box  VarParam:map-many, set  VarParam:map-one to box  VarParam:map-one,Boxset  lambda (f lists):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:lists to box  VarParam:lists, if: applic  boxGetapplic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetBoxset  lambda (f s):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:s to box  VarParam:s, if: applic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet symbol:whatever symbol:whatever varfree:null? varfree:car varfree:cdr varfree:cons varfree:apply
; varfree:apply
mov rax, qword[fvar_tbl + WORD_SIZE*31 ]
push rax
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
push rax
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
push rax
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
push rax
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 5
; lambda (null? car cdr cons apply):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:cons to box  VarParam:cons, set  VarParam:apply to box  VarParam:apply,applicTP   lambda (map-many map-one):seq:   set  VarParam:map-many to box  VarParam:map-many, set  VarParam:map-one to box  VarParam:map-one,Boxset  lambda (f lists):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:lists to box  VarParam:lists, if: applic  boxGetapplic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetBoxset  lambda (f s):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:s to box  VarParam:s, if: applic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet symbol:whatever symbol:whatever

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode1)
jmp Lcont1
Lcode1:
push rbp
mov rbp, rsp
;seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:cons to box  VarParam:cons, set  VarParam:apply to box  VarParam:apply,applicTP   lambda (map-many map-one):seq:   set  VarParam:map-many to box  VarParam:map-many, set  VarParam:map-one to box  VarParam:map-one,Boxset  lambda (f lists):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:lists to box  VarParam:lists, if: applic  boxGetapplic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetBoxset  lambda (f s):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:s to box  VarParam:s, if: applic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet symbol:whatever symbol:whatever
;box  VarParam:null?,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:car,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cdr,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cons,
mov rax, qword[rbp+8 * (4+3)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:apply,
mov rax, qword[rbp+8 * (4+4)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (map-many map-one):seq:   set  VarParam:map-many to box  VarParam:map-many, set  VarParam:map-one to box  VarParam:map-one,Boxset  lambda (f lists):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:lists to box  VarParam:lists, if: applic  boxGetapplic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetBoxset  lambda (f s):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:s to box  VarParam:s, if: applic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet symbol:whatever symbol:whatever
;args
mov rax, const_tbl+23
push rax
mov rax, const_tbl+23
push rax
push 2
;body
; lambda (map-many map-one):seq:   set  VarParam:map-many to box  VarParam:map-many, set  VarParam:map-one to box  VarParam:map-one,Boxset  lambda (f lists):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:lists to box  VarParam:lists, if: applic  boxGetapplic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetBoxset  lambda (f s):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:s to box  VarParam:s, if: applic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode2)
jmp Lcont2
Lcode2:
push rbp
mov rbp, rsp
;seq:   set  VarParam:map-many to box  VarParam:map-many, set  VarParam:map-one to box  VarParam:map-one,Boxset  lambda (f lists):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:lists to box  VarParam:lists, if: applic  boxGetapplic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetBoxset  lambda (f s):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:s to box  VarParam:s, if: applic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet
;box  VarParam:map-many,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:map-one,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (f lists):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:lists to box  VarParam:lists, if: applic  boxGetapplic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode3)
jmp Lcont3
Lcode3:
push rbp
mov rbp, rsp
;seq:   set  VarParam:f to box  VarParam:f, set  VarParam:lists to box  VarParam:lists, if: applic  boxGetapplic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGet
;box  VarParam:f,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:lists,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse4

                    mov rax, const_tbl+1
 jmp Lexit4
 Lelse4:
                    ;applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetboxGet
;args
;applic  boxGetboxGetapplic  boxGetboxGetboxGet
;applic  boxGetboxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGetapplic  boxGetboxGetboxGet
;applic  boxGetboxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*4]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit4:
leave
ret
Lcont3:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

; lambda (f s):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:s to box  VarParam:s, if: applic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode5)
jmp Lcont5
Lcode5:
push rbp
mov rbp, rsp
;seq:   set  VarParam:f to box  VarParam:f, set  VarParam:s to box  VarParam:s, if: applic  boxGetboxGetthen: nil|boolelse applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGet
;box  VarParam:f,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:s,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse6

                    mov rax, const_tbl+1
 jmp Lexit6
 Lelse6:
                    ;applicTP  boxGetapplic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit6:
leave
ret
Lcont5:


                              push rax

                              mov rax, qword[rbp+8 * (4+1)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (): lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet
;args
push 0
;body
; lambda (): lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode7)
jmp Lcont7
Lcode7:
push rbp
mov rbp, rsp
; lambdaOpt f):seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode8)
jmp Lcont8
Lcode8:
FIX_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
;seq:   set  VarParam:f to box  VarParam:f, set  VarParam:args to box  VarParam:args,applicTP  boxGetboxGetboxGet
;box  VarParam:f,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:args,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont8:

leave
ret
Lcont7:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 2
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont2:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont1:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*68], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def fold-left
; lambda (func acc list):seq:   set  VarParam:func to box  VarParam:func, set  VarParam:acc to box  VarParam:acc, set  VarParam:list to box  VarParam:list, if: applic   varfree:null?boxGetthen: boxGetelse applicTP   varfree:fold-leftboxGetapplic  boxGetboxGetapplic   varfree:carboxGetapplic   varfree:cdrboxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode9)
jmp Lcont9
Lcode9:
push rbp
mov rbp, rsp
;seq:   set  VarParam:func to box  VarParam:func, set  VarParam:acc to box  VarParam:acc, set  VarParam:list to box  VarParam:list, if: applic   varfree:null?boxGetthen: boxGetelse applicTP   varfree:fold-leftboxGetapplic  boxGetboxGetapplic   varfree:carboxGetapplic   varfree:cdrboxGet
;box  VarParam:func,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:acc,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:list,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic   varfree:null?boxGet
mov rax, qword[rbp+8 * (4+2)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse10

                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 jmp Lexit10
 Lelse10:
                    ;applicTP   varfree:fold-leftboxGetapplic  boxGetboxGetapplic   varfree:carboxGetapplic   varfree:cdrboxGet
;args
;applic   varfree:cdrboxGet
mov rax, qword[rbp+8 * (4+2)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGetapplic   varfree:carboxGet
;applic   varfree:carboxGet
mov rax, qword[rbp+8 * (4+2)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 3
;body
; varfree:fold-left
mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit10:
leave
ret
Lcont9:

mov qword [fvar_tbl + WORD_SIZE*50], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def fold-right
; lambda (func acc list):seq:   set  VarParam:func to box  VarParam:func, set  VarParam:acc to box  VarParam:acc, set  VarParam:list to box  VarParam:list, if: applic   varfree:null?boxGetthen: boxGetelse applicTP  boxGetapplic   varfree:carboxGetapplic   varfree:fold-rightboxGetboxGetapplic   varfree:cdrboxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode11)
jmp Lcont11
Lcode11:
push rbp
mov rbp, rsp
;seq:   set  VarParam:func to box  VarParam:func, set  VarParam:acc to box  VarParam:acc, set  VarParam:list to box  VarParam:list, if: applic   varfree:null?boxGetthen: boxGetelse applicTP  boxGetapplic   varfree:carboxGetapplic   varfree:fold-rightboxGetboxGetapplic   varfree:cdrboxGet
;box  VarParam:func,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:acc,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:list,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic   varfree:null?boxGet
mov rax, qword[rbp+8 * (4+2)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse12

                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 jmp Lexit12
 Lelse12:
                    ;applicTP  boxGetapplic   varfree:carboxGetapplic   varfree:fold-rightboxGetboxGetapplic   varfree:cdrboxGet
;args
;applic   varfree:fold-rightboxGetboxGetapplic   varfree:cdrboxGet
;applic   varfree:cdrboxGet
mov rax, qword[rbp+8 * (4+2)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 3
; varfree:fold-right
mov rax, qword[fvar_tbl + WORD_SIZE*34 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic   varfree:carboxGet
mov rax, qword[rbp+8 * (4+2)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit12:
leave
ret
Lcont11:

mov qword [fvar_tbl + WORD_SIZE*34], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def cons*
; lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic   varfree:null?applic   varfree:cdrboxGetthen: applicTP   varfree:carboxGetelse applicTP   varfree:consapplic   varfree:carboxGetapplic   varfree:apply varfree:cons*applic   varfree:cdrboxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode13)
jmp Lcont13
Lcode13:
FIX_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, if: applic   varfree:null?applic   varfree:cdrboxGetthen: applicTP   varfree:carboxGetelse applicTP   varfree:consapplic   varfree:carboxGetapplic   varfree:apply varfree:cons*applic   varfree:cdrboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic   varfree:null?applic   varfree:cdrboxGet
;applic   varfree:cdrboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse14

                    ;applicTP   varfree:carboxGet
;args
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
;body
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit14
 Lelse14:
                    ;applicTP   varfree:consapplic   varfree:carboxGetapplic   varfree:apply varfree:cons*applic   varfree:cdrboxGet
;args
;applic   varfree:apply varfree:cons*applic   varfree:cdrboxGet
;applic   varfree:cdrboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; varfree:cons*
mov rax, qword[fvar_tbl + WORD_SIZE*32 ]
push rax
push 2
; varfree:apply
mov rax, qword[fvar_tbl + WORD_SIZE*31 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic   varfree:carboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit14:
leave
ret
Lcont13:

mov qword [fvar_tbl + WORD_SIZE*32], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def append
;applic   lambda (null? fold-right cons):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:fold-right to box  VarParam:fold-right, set  VarParam:cons to box  VarParam:cons, lambdaOpt ):seq:   set  VarParam:args to box  VarParam:args,applicTP  boxGet lambda (e a):seq:   set  VarParam:e to box  VarParam:e, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetboxGetboxGetboxGetnil|boolboxGet varfree:null? varfree:fold-right varfree:cons
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
push rax
; varfree:fold-right
mov rax, qword[fvar_tbl + WORD_SIZE*34 ]
push rax
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3
; lambda (null? fold-right cons):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:fold-right to box  VarParam:fold-right, set  VarParam:cons to box  VarParam:cons, lambdaOpt ):seq:   set  VarParam:args to box  VarParam:args,applicTP  boxGet lambda (e a):seq:   set  VarParam:e to box  VarParam:e, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetboxGetboxGetboxGetnil|boolboxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode15)
jmp Lcont15
Lcode15:
push rbp
mov rbp, rsp
;seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:fold-right to box  VarParam:fold-right, set  VarParam:cons to box  VarParam:cons, lambdaOpt ):seq:   set  VarParam:args to box  VarParam:args,applicTP  boxGet lambda (e a):seq:   set  VarParam:e to box  VarParam:e, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetboxGetboxGetboxGetnil|boolboxGet
;box  VarParam:null?,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:fold-right,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cons,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambdaOpt ):seq:   set  VarParam:args to box  VarParam:args,applicTP  boxGet lambda (e a):seq:   set  VarParam:e to box  VarParam:e, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetboxGetboxGetboxGetnil|boolboxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode16)
jmp Lcont16
Lcode16:
FIX_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
;seq:   set  VarParam:args to box  VarParam:args,applicTP  boxGet lambda (e a):seq:   set  VarParam:e to box  VarParam:e, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetboxGetboxGetboxGetnil|boolboxGet
;box  VarParam:args,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGet lambda (e a):seq:   set  VarParam:e to box  VarParam:e, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetboxGetboxGetboxGetnil|boolboxGet
;args
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+1
push rax
; lambda (e a):seq:   set  VarParam:e to box  VarParam:e, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetboxGetboxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode17)
jmp Lcont17
Lcode17:
push rbp
mov rbp, rsp
;seq:   set  VarParam:e to box  VarParam:e, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetboxGetboxGetboxGet
;box  VarParam:e,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:a,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse18

                    mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 jmp Lexit18
 Lelse18:
                    ;applicTP  boxGetboxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
push rax
push 3
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit18:
leave
ret
Lcont17:

push rax
push 3
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont16:

leave
ret
Lcont15:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*33], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def list
; lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x,boxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode19)
jmp Lcont19
Lcode19:
FIX_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x,boxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
leave
ret
Lcont19:

mov qword [fvar_tbl + WORD_SIZE*35], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def list?
;applic   lambda (null? pair? cdr):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:pair? to box  VarParam:pair?, set  VarParam:cdr to box  VarParam:cdr,applicTP   lambda (list?-loop):seq:   set  VarParam:list?-loop to box  VarParam:list?-loop,Boxset  lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGet if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda ():boxGet symbol:whatever varfree:null? varfree:pair? varfree:cdr
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
push rax
; varfree:pair?
mov rax, qword[fvar_tbl + WORD_SIZE*3 ]
push rax
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3
; lambda (null? pair? cdr):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:pair? to box  VarParam:pair?, set  VarParam:cdr to box  VarParam:cdr,applicTP   lambda (list?-loop):seq:   set  VarParam:list?-loop to box  VarParam:list?-loop,Boxset  lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGet if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda ():boxGet symbol:whatever

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode20)
jmp Lcont20
Lcode20:
push rbp
mov rbp, rsp
;seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:pair? to box  VarParam:pair?, set  VarParam:cdr to box  VarParam:cdr,applicTP   lambda (list?-loop):seq:   set  VarParam:list?-loop to box  VarParam:list?-loop,Boxset  lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGet if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda ():boxGet symbol:whatever
;box  VarParam:null?,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:pair?,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cdr,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (list?-loop):seq:   set  VarParam:list?-loop to box  VarParam:list?-loop,Boxset  lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGet if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda ():boxGet symbol:whatever
;args
mov rax, const_tbl+23
push rax
push 1
;body
; lambda (list?-loop):seq:   set  VarParam:list?-loop to box  VarParam:list?-loop,Boxset  lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGet if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda ():boxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode21)
jmp Lcont21
Lcode21:
push rbp
mov rbp, rsp
;seq:   set  VarParam:list?-loop to box  VarParam:list?-loop,Boxset  lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGet if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda ():boxGet
;box  VarParam:list?-loop,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGet if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetelse nil|bool

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode22)
jmp Lcont22
Lcode22:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGet if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetelse nil|bool
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit23
    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse24

                    ;applicTP  boxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit24
 Lelse24:
                    mov rax, const_tbl+2
 Lexit24:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit23
    
Lexit23:
leave
ret
Lcont22:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda ():boxGet
;args
push 0
;body
; lambda ():boxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode25)
jmp Lcont25
Lcode25:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
leave
ret
Lcont25:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 2
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont21:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont20:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*36], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def make-string
;applic   lambda (null? car make-string):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:make-string to box  VarParam:make-string, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGetboxGet charelse applicTP  boxGetboxGetapplic  boxGetboxGet varfree:null? varfree:car varfree:make-string
; varfree:make-string
mov rax, qword[fvar_tbl + WORD_SIZE*12 ]
push rax
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
push rax
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3
; lambda (null? car make-string):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:make-string to box  VarParam:make-string, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGetboxGet charelse applicTP  boxGetboxGetapplic  boxGetboxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode26)
jmp Lcont26
Lcode26:
push rbp
mov rbp, rsp
;seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:make-string to box  VarParam:make-string, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGetboxGet charelse applicTP  boxGetboxGetapplic  boxGetboxGet
;box  VarParam:null?,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:car,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:make-string,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGetboxGet charelse applicTP  boxGetboxGetapplic  boxGetboxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode27)
jmp Lcont27
Lcode27:
FIX_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGetboxGet charelse applicTP  boxGetboxGetapplic  boxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:y,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse28

                    ;applicTP  boxGetboxGet char
;args
mov rax, const_tbl+32
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit28
 Lelse28:
                    ;applicTP  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit28:
leave
ret
Lcont27:

leave
ret
Lcont26:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*12], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def not
; lambda (x):seq:   set  VarParam:x to box  VarParam:x, if: boxGetthen: nil|boolelse nil|bool

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode29)
jmp Lcont29
Lcode29:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, if: boxGetthen: nil|boolelse nil|bool
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 je Lelse30

                    mov rax, const_tbl+2
 jmp Lexit30
 Lelse30:
                    mov rax, const_tbl+4
 Lexit30:
leave
ret
Lcont29:

mov qword [fvar_tbl + WORD_SIZE*42], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic   lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?):seq:   set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:rational? to box  VarParam:rational?, set  VarParam:exact->inexact to box  VarParam:exact->inexact, set  VarParam:fold-left to box  VarParam:fold-left, set  VarParam:map to box  VarParam:map, set  VarParam:_+ to box  VarParam:_+, set  VarParam:_* to box  VarParam:_*, set  VarParam:_/ to box  VarParam:_/, set  VarParam:_= to box  VarParam:_=, set  VarParam:_< to box  VarParam:_<, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:null? to box  VarParam:null?,applicTP   lambda (^numeric-op-dispatcher):seq:   set  VarParam:^numeric-op-dispatcher to box  VarParam:^numeric-op-dispatcher,Boxset +Boxset *Boxset /applicTP   lambda (^comparator):seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset < lambda (op):seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever lambda (op):seq:   set  VarParam:op to box  VarParam:op, lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetboxGetelse applicTP  boxGetboxGetboxGet varfree:flonum? varfree:rational? varfree:exact->inexact varfree:fold-left varfree:map varfree:+ varfree:* varfree:/ varfree:= varfree:< varfree:car varfree:cdr varfree:null?
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
push rax
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
push rax
; varfree:<
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
; varfree:=
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
; varfree:/
mov rax, qword[fvar_tbl + WORD_SIZE*20 ]
push rax
; varfree:*
mov rax, qword[fvar_tbl + WORD_SIZE*19 ]
push rax
; varfree:+
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
push rax
; varfree:map
mov rax, qword[fvar_tbl + WORD_SIZE*68 ]
push rax
; varfree:fold-left
mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
push rax
; varfree:exact->inexact
mov rax, qword[fvar_tbl + WORD_SIZE*16 ]
push rax
; varfree:rational?
mov rax, qword[fvar_tbl + WORD_SIZE*2 ]
push rax
; varfree:flonum?
mov rax, qword[fvar_tbl + WORD_SIZE*1 ]
push rax
push 13
; lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?):seq:   set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:rational? to box  VarParam:rational?, set  VarParam:exact->inexact to box  VarParam:exact->inexact, set  VarParam:fold-left to box  VarParam:fold-left, set  VarParam:map to box  VarParam:map, set  VarParam:_+ to box  VarParam:_+, set  VarParam:_* to box  VarParam:_*, set  VarParam:_/ to box  VarParam:_/, set  VarParam:_= to box  VarParam:_=, set  VarParam:_< to box  VarParam:_<, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:null? to box  VarParam:null?,applicTP   lambda (^numeric-op-dispatcher):seq:   set  VarParam:^numeric-op-dispatcher to box  VarParam:^numeric-op-dispatcher,Boxset +Boxset *Boxset /applicTP   lambda (^comparator):seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset < lambda (op):seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever lambda (op):seq:   set  VarParam:op to box  VarParam:op, lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetboxGetelse applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode31)
jmp Lcont31
Lcode31:
push rbp
mov rbp, rsp
;seq:   set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:rational? to box  VarParam:rational?, set  VarParam:exact->inexact to box  VarParam:exact->inexact, set  VarParam:fold-left to box  VarParam:fold-left, set  VarParam:map to box  VarParam:map, set  VarParam:_+ to box  VarParam:_+, set  VarParam:_* to box  VarParam:_*, set  VarParam:_/ to box  VarParam:_/, set  VarParam:_= to box  VarParam:_=, set  VarParam:_< to box  VarParam:_<, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:null? to box  VarParam:null?,applicTP   lambda (^numeric-op-dispatcher):seq:   set  VarParam:^numeric-op-dispatcher to box  VarParam:^numeric-op-dispatcher,Boxset +Boxset *Boxset /applicTP   lambda (^comparator):seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset < lambda (op):seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever lambda (op):seq:   set  VarParam:op to box  VarParam:op, lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetboxGetelse applicTP  boxGetboxGetboxGet
;box  VarParam:flonum?,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:rational?,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:exact->inexact,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:fold-left,
mov rax, qword[rbp+8 * (4+3)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:map,
mov rax, qword[rbp+8 * (4+4)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:_+,
mov rax, qword[rbp+8 * (4+5)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+5)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:_*,
mov rax, qword[rbp+8 * (4+6)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+6)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:_/,
mov rax, qword[rbp+8 * (4+7)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+7)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:_=,
mov rax, qword[rbp+8 * (4+8)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+8)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:_<,
mov rax, qword[rbp+8 * (4+9)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+9)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:car,
mov rax, qword[rbp+8 * (4+10)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+10)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cdr,
mov rax, qword[rbp+8 * (4+11)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+11)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:null?,
mov rax, qword[rbp+8 * (4+12)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+12)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (^numeric-op-dispatcher):seq:   set  VarParam:^numeric-op-dispatcher to box  VarParam:^numeric-op-dispatcher,Boxset +Boxset *Boxset /applicTP   lambda (^comparator):seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset < lambda (op):seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever lambda (op):seq:   set  VarParam:op to box  VarParam:op, lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetboxGetelse applicTP  boxGetboxGetboxGet
;args
; lambda (op):seq:   set  VarParam:op to box  VarParam:op, lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetboxGetelse applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode46)
jmp Lcont46
Lcode46:
push rbp
mov rbp, rsp
;seq:   set  VarParam:op to box  VarParam:op, lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetboxGetelse applicTP  boxGetboxGetboxGet
;box  VarParam:op,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetboxGetelse applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode47)
jmp Lcont47
Lcode47:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetboxGetelse applicTP  boxGetboxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:y,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse51

                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 jmp Lexit51
 Lelse51:
                    mov rax, const_tbl+2
 Lexit51:
 cmp rax, SOB_FALSE_ADDRESS
 je Lelse48

                    ;applicTP  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit48
 Lelse48:
                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse50

                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 jmp Lexit50
 Lelse50:
                    mov rax, const_tbl+2
 Lexit50:
 cmp rax, SOB_FALSE_ADDRESS
 je Lelse49

                    ;applicTP  boxGetapplic  boxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit49
 Lelse49:
                    ;applicTP  boxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit49:
 Lexit48:
leave
ret
Lcont47:

leave
ret
Lcont46:

push rax
push 1
;body
; lambda (^numeric-op-dispatcher):seq:   set  VarParam:^numeric-op-dispatcher to box  VarParam:^numeric-op-dispatcher,Boxset +Boxset *Boxset /applicTP   lambda (^comparator):seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset < lambda (op):seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode32)
jmp Lcont32
Lcode32:
push rbp
mov rbp, rsp
;seq:   set  VarParam:^numeric-op-dispatcher to box  VarParam:^numeric-op-dispatcher,Boxset +Boxset *Boxset /applicTP   lambda (^comparator):seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset < lambda (op):seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever
;box  VarParam:^numeric-op-dispatcher,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetapplic  boxGetboxGet number 0,1boxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode33)
jmp Lcont33
Lcode33:
FIX_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetapplic  boxGetboxGet number 0,1boxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGetapplic  boxGetboxGet number 0,1boxGet
;args
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+34
push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*5]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 3
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont33:


                              push rax

                              ; varfree:+
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

; lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetapplic  boxGetboxGet number 1,1boxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode34)
jmp Lcont34
Lcode34:
FIX_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetapplic  boxGetboxGet number 1,1boxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGetapplic  boxGetboxGet number 1,1boxGet
;args
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+51
push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*6]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 3
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont34:


                              push rax

                              ; varfree:*
mov rax, qword[fvar_tbl + WORD_SIZE*19 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applic   lambda (/):seq:   set  VarParam:/ to box  VarParam:/, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 1,1boxGetelse applicTP  boxGetboxGetboxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*7]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
; lambda (/):seq:   set  VarParam:/ to box  VarParam:/, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 1,1boxGetelse applicTP  boxGetboxGetboxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode35)
jmp Lcont35
Lcode35:
push rbp
mov rbp, rsp
;seq:   set  VarParam:/ to box  VarParam:/, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 1,1boxGetelse applicTP  boxGetboxGetboxGetboxGet
;box  VarParam:/,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 1,1boxGetelse applicTP  boxGetboxGetboxGetboxGet

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode36)
jmp Lcont36
Lcode36:
FIX_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 1,1boxGetelse applicTP  boxGetboxGetboxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:y,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*12]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse37

                    ;applicTP  boxGet number 1,1boxGet
;args
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+51
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit37
 Lelse37:
                    ;applicTP  boxGetboxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
push rax
push 3
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit37:
leave
ret
Lcont36:

leave
ret
Lcont35:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args


                              push rax

                              ; varfree:/
mov rax, qword[fvar_tbl + WORD_SIZE*20 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (^comparator):seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset < lambda (op):seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever
;args
; lambda (op):seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode39)
jmp Lcont39
Lcode39:
push rbp
mov rbp, rsp
;seq:   set  VarParam:op to box  VarParam:op,applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever
;box  VarParam:op,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever
;args
mov rax, const_tbl+23
push rax
push 1
;body
; lambda (comparator):seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode40)
jmp Lcont40
Lcode40:
push rbp
mov rbp, rsp
;seq:   set  VarParam:comparator to box  VarParam:comparator,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet
;box  VarParam:comparator,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|bool

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode41)
jmp Lcont41
Lcode41:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|bool
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:ys,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*3]
                                        mov rax, qword[rax+8*12]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit42
    ;applic  boxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*3]
                                        mov rax, qword[rax+8*10]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse43

                    ;applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*3]
                                        mov rax, qword[rax+8*11]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*3]
                                        mov rax, qword[rax+8*10]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit43
 Lelse43:
                    mov rax, const_tbl+2
 Lexit43:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit42
    
Lexit42:
leave
ret
Lcont41:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet
;args
push 0
;body
; lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode44)
jmp Lcont44
Lcode44:
push rbp
mov rbp, rsp
; lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 5
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode45)
jmp Lcont45
Lcode45:
FIX_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:y,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont45:

leave
ret
Lcont44:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 2
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont40:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont39:

push rax
push 1
;body
; lambda (^comparator):seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset <

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode38)
jmp Lcont38
Lcode38:
push rbp
mov rbp, rsp
;seq:   set  VarParam:^comparator to box  VarParam:^comparator,Boxset =Boxset <
;box  VarParam:^comparator,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*8]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args


                              push rax

                              ; varfree:=
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*9]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args


                              push rax

                              ; varfree:<
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

leave
ret
Lcont38:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont32:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont31:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

	call write_sob_if_not_void

;def -
;applic   lambda (apply + null?):seq:   set  VarParam:apply to box  VarParam:apply, set  VarParam:+ to box  VarParam:+, set  VarParam:null? to box  VarParam:null?, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 0,1applic   varfree:* number -1,1boxGetelse applicTP  boxGetboxGetapplic   varfree:* number -1,1applic  boxGetboxGetboxGet varfree:apply varfree:+ varfree:null?
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
; varfree:+
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
push rax
; varfree:apply
mov rax, qword[fvar_tbl + WORD_SIZE*31 ]
push rax
push 3
; lambda (apply + null?):seq:   set  VarParam:apply to box  VarParam:apply, set  VarParam:+ to box  VarParam:+, set  VarParam:null? to box  VarParam:null?, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 0,1applic   varfree:* number -1,1boxGetelse applicTP  boxGetboxGetapplic   varfree:* number -1,1applic  boxGetboxGetboxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode52)
jmp Lcont52
Lcode52:
push rbp
mov rbp, rsp
;seq:   set  VarParam:apply to box  VarParam:apply, set  VarParam:+ to box  VarParam:+, set  VarParam:null? to box  VarParam:null?, lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 0,1applic   varfree:* number -1,1boxGetelse applicTP  boxGetboxGetapplic   varfree:* number -1,1applic  boxGetboxGetboxGet
;box  VarParam:apply,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:+,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:null?,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 0,1applic   varfree:* number -1,1boxGetelse applicTP  boxGetboxGetapplic   varfree:* number -1,1applic  boxGetboxGetboxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode53)
jmp Lcont53
Lcode53:
FIX_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if: applic  boxGetboxGetthen: applicTP  boxGet number 0,1applic   varfree:* number -1,1boxGetelse applicTP  boxGetboxGetapplic   varfree:* number -1,1applic  boxGetboxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:y,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse54

                    ;applicTP  boxGet number 0,1applic   varfree:* number -1,1boxGet
;args
;applic   varfree:* number -1,1boxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+68
push rax
push 2
; varfree:*
mov rax, qword[fvar_tbl + WORD_SIZE*19 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, const_tbl+34
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit54
 Lelse54:
                    ;applicTP  boxGetboxGetapplic   varfree:* number -1,1applic  boxGetboxGetboxGet
;args
;applic   varfree:* number -1,1applic  boxGetboxGetboxGet
;applic  boxGetboxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, const_tbl+68
push rax
push 2
; varfree:*
mov rax, qword[fvar_tbl + WORD_SIZE*19 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit54:
leave
ret
Lcont53:

leave
ret
Lcont52:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*55], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def >
;applic   lambda (null? not car cdr < =):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:not to box  VarParam:not, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:< to box  VarParam:<, set  VarParam:= to box  VarParam:=,applicTP   lambda (>-loop):seq:   set  VarParam:>-loop to box  VarParam:>-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever varfree:null? varfree:not varfree:car varfree:cdr varfree:< varfree:=
; varfree:=
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
; varfree:<
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
push rax
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
push rax
; varfree:not
mov rax, qword[fvar_tbl + WORD_SIZE*42 ]
push rax
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 6
; lambda (null? not car cdr < =):seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:not to box  VarParam:not, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:< to box  VarParam:<, set  VarParam:= to box  VarParam:=,applicTP   lambda (>-loop):seq:   set  VarParam:>-loop to box  VarParam:>-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode55)
jmp Lcont55
Lcode55:
push rbp
mov rbp, rsp
;seq:   set  VarParam:null? to box  VarParam:null?, set  VarParam:not to box  VarParam:not, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:< to box  VarParam:<, set  VarParam:= to box  VarParam:=,applicTP   lambda (>-loop):seq:   set  VarParam:>-loop to box  VarParam:>-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever
;box  VarParam:null?,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:not,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:car,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cdr,
mov rax, qword[rbp+8 * (4+3)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:<,
mov rax, qword[rbp+8 * (4+4)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:=,
mov rax, qword[rbp+8 * (4+5)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+5)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (>-loop):seq:   set  VarParam:>-loop to box  VarParam:>-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet symbol:whatever
;args
mov rax, const_tbl+23
push rax
push 1
;body
; lambda (>-loop):seq:   set  VarParam:>-loop to box  VarParam:>-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode56)
jmp Lcont56
Lcode56:
push rbp
mov rbp, rsp
;seq:   set  VarParam:>-loop to box  VarParam:>-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse nil|boolapplicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet
;box  VarParam:>-loop,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse nil|bool

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode57)
jmp Lcont57
Lcode57:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, applic  boxGetboxGet if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse nil|bool
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:ys,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit58
    ;applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*4]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse59

                    ;applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*5]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse60

                    ;applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit60
 Lelse60:
                    mov rax, const_tbl+2
 Lexit60:
 jmp Lexit59
 Lelse59:
                    mov rax, const_tbl+2
 Lexit59:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit58
    
Lexit58:
leave
ret
Lcont57:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet
;args
push 0
;body
; lambda (): lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode61)
jmp Lcont61
Lcode61:
push rbp
mov rbp, rsp
; lambdaOpt x):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode62)
jmp Lcont62
Lcode62:
FIX_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y,applicTP  boxGetboxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:y,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont62:

leave
ret
Lcont61:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 2
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont56:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont55:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*41], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def gcd
;applic   lambda (gcd null? car cdr):seq:   set  VarParam:gcd to box  VarParam:gcd, set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr,applicTP   lambda (gcd-loop):seq:   set  VarParam:gcd-loop to box  VarParam:gcd-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet symbol:whatever varfree:gcd varfree:null? varfree:car varfree:cdr
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
push rax
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
push rax
; varfree:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
; varfree:gcd
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
push 4
; lambda (gcd null? car cdr):seq:   set  VarParam:gcd to box  VarParam:gcd, set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr,applicTP   lambda (gcd-loop):seq:   set  VarParam:gcd-loop to box  VarParam:gcd-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet symbol:whatever

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode63)
jmp Lcont63
Lcode63:
push rbp
mov rbp, rsp
;seq:   set  VarParam:gcd to box  VarParam:gcd, set  VarParam:null? to box  VarParam:null?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr,applicTP   lambda (gcd-loop):seq:   set  VarParam:gcd-loop to box  VarParam:gcd-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet symbol:whatever
;box  VarParam:gcd,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:null?,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:car,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cdr,
mov rax, qword[rbp+8 * (4+3)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (gcd-loop):seq:   set  VarParam:gcd-loop to box  VarParam:gcd-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet symbol:whatever
;args
mov rax, const_tbl+23
push rax
push 1
;body
; lambda (gcd-loop):seq:   set  VarParam:gcd-loop to box  VarParam:gcd-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode64)
jmp Lcont64
Lcode64:
push rbp
mov rbp, rsp
;seq:   set  VarParam:gcd-loop to box  VarParam:gcd-loop,Boxset  lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGetapplicTP   lambda (): lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;box  VarParam:gcd-loop,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x ys):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode65)
jmp Lcont65
Lcode65:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:ys to box  VarParam:ys, if: applic  boxGetboxGetthen: boxGetelse applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:ys,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse66

                    mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 jmp Lexit66
 Lelse66:
                    ;applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit66:
leave
ret
Lcont65:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (): lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
push 0
;body
; lambda (): lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode67)
jmp Lcont67
Lcode67:
push rbp
mov rbp, rsp
; lambdaOpt ):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode68)
jmp Lcont68
Lcode68:
FIX_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen:  number 0,1else applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse69

                    mov rax, const_tbl+34
 jmp Lexit69
 Lelse69:
                    ;applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit69:
leave
ret
Lcont68:

leave
ret
Lcont67:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 2
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont64:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont63:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*25], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def zero?
;applic   lambda (=):seq:   set  VarParam:= to box  VarParam:=, lambda (x):seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetboxGet number 0,1 varfree:=
; varfree:=
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
push 1
; lambda (=):seq:   set  VarParam:= to box  VarParam:=, lambda (x):seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetboxGet number 0,1

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode70)
jmp Lcont70
Lcode70:
push rbp
mov rbp, rsp
;seq:   set  VarParam:= to box  VarParam:=, lambda (x):seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetboxGet number 0,1
;box  VarParam:=,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x):seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetboxGet number 0,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode71)
jmp Lcont71
Lcode71:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x,applicTP  boxGetboxGet number 0,1
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGetboxGet number 0,1
;args
mov rax, const_tbl+34
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont71:

leave
ret
Lcont70:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*45], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def integer?
;applic   lambda (rational? = denominator):seq:   set  VarParam:rational? to box  VarParam:rational?, set  VarParam:= to box  VarParam:=, set  VarParam:denominator to box  VarParam:denominator, lambda (x):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGet number 1,1else nil|bool varfree:rational? varfree:= varfree:denominator
; varfree:denominator
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
; varfree:=
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
; varfree:rational?
mov rax, qword[fvar_tbl + WORD_SIZE*2 ]
push rax
push 3
; lambda (rational? = denominator):seq:   set  VarParam:rational? to box  VarParam:rational?, set  VarParam:= to box  VarParam:=, set  VarParam:denominator to box  VarParam:denominator, lambda (x):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGet number 1,1else nil|bool

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode72)
jmp Lcont72
Lcode72:
push rbp
mov rbp, rsp
;seq:   set  VarParam:rational? to box  VarParam:rational?, set  VarParam:= to box  VarParam:=, set  VarParam:denominator to box  VarParam:denominator, lambda (x):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGet number 1,1else nil|bool
;box  VarParam:rational?,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:=,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:denominator,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x):seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGet number 1,1else nil|bool

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode73)
jmp Lcont73
Lcode73:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, if: applic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGet number 1,1else nil|bool
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse74

                    ;applicTP  boxGetapplic  boxGetboxGet number 1,1
;args
mov rax, const_tbl+51
push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit74
 Lelse74:
                    mov rax, const_tbl+2
 Lexit74:
leave
ret
Lcont73:

leave
ret
Lcont72:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*46], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def number?
;applic   lambda (flonum? rational?):seq:   set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:rational? to box  VarParam:rational?, lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGetapplicTP  boxGetboxGet varfree:flonum? varfree:rational?
; varfree:rational?
mov rax, qword[fvar_tbl + WORD_SIZE*2 ]
push rax
; varfree:flonum?
mov rax, qword[fvar_tbl + WORD_SIZE*1 ]
push rax
push 2
; lambda (flonum? rational?):seq:   set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:rational? to box  VarParam:rational?, lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGetapplicTP  boxGetboxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode75)
jmp Lcont75
Lcode75:
push rbp
mov rbp, rsp
;seq:   set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:rational? to box  VarParam:rational?, lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGetapplicTP  boxGetboxGet
;box  VarParam:flonum?,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:rational?,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x):seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGetapplicTP  boxGetboxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode76)
jmp Lcont76
Lcode76:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, applic  boxGetboxGetapplicTP  boxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit77
    ;applicTP  boxGetboxGet
;args
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit77
    
Lexit77:
leave
ret
Lcont76:

leave
ret
Lcont75:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*48], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def length
;applic   lambda (fold-left +):seq:   set  VarParam:fold-left to box  VarParam:fold-left, set  VarParam:+ to box  VarParam:+, lambda (l):seq:   set  VarParam:l to box  VarParam:l,applicTP  boxGet lambda (acc e):seq:   set  VarParam:acc to box  VarParam:acc, set  VarParam:e to box  VarParam:e,applicTP  boxGetboxGet number 1,1 number 0,1boxGet varfree:fold-left varfree:+
; varfree:+
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
push rax
; varfree:fold-left
mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
push rax
push 2
; lambda (fold-left +):seq:   set  VarParam:fold-left to box  VarParam:fold-left, set  VarParam:+ to box  VarParam:+, lambda (l):seq:   set  VarParam:l to box  VarParam:l,applicTP  boxGet lambda (acc e):seq:   set  VarParam:acc to box  VarParam:acc, set  VarParam:e to box  VarParam:e,applicTP  boxGetboxGet number 1,1 number 0,1boxGet

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode78)
jmp Lcont78
Lcode78:
push rbp
mov rbp, rsp
;seq:   set  VarParam:fold-left to box  VarParam:fold-left, set  VarParam:+ to box  VarParam:+, lambda (l):seq:   set  VarParam:l to box  VarParam:l,applicTP  boxGet lambda (acc e):seq:   set  VarParam:acc to box  VarParam:acc, set  VarParam:e to box  VarParam:e,applicTP  boxGetboxGet number 1,1 number 0,1boxGet
;box  VarParam:fold-left,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:+,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (l):seq:   set  VarParam:l to box  VarParam:l,applicTP  boxGet lambda (acc e):seq:   set  VarParam:acc to box  VarParam:acc, set  VarParam:e to box  VarParam:e,applicTP  boxGetboxGet number 1,1 number 0,1boxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode79)
jmp Lcont79
Lcode79:
push rbp
mov rbp, rsp
;seq:   set  VarParam:l to box  VarParam:l,applicTP  boxGet lambda (acc e):seq:   set  VarParam:acc to box  VarParam:acc, set  VarParam:e to box  VarParam:e,applicTP  boxGetboxGet number 1,1 number 0,1boxGet
;box  VarParam:l,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGet lambda (acc e):seq:   set  VarParam:acc to box  VarParam:acc, set  VarParam:e to box  VarParam:e,applicTP  boxGetboxGet number 1,1 number 0,1boxGet
;args
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+34
push rax
; lambda (acc e):seq:   set  VarParam:acc to box  VarParam:acc, set  VarParam:e to box  VarParam:e,applicTP  boxGetboxGet number 1,1

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode80)
jmp Lcont80
Lcode80:
push rbp
mov rbp, rsp
;seq:   set  VarParam:acc to box  VarParam:acc, set  VarParam:e to box  VarParam:e,applicTP  boxGetboxGet number 1,1
;box  VarParam:acc,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:e,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP  boxGetboxGet number 1,1
;args
mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont80:

push rax
push 3
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont79:

leave
ret
Lcont78:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*49], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def string->list
;applic   lambda (string-ref string-length < - cons):seq:   set  VarParam:string-ref to box  VarParam:string-ref, set  VarParam:string-length to box  VarParam:string-length, set  VarParam:< to box  VarParam:<, set  VarParam:- to box  VarParam:-, set  VarParam:cons to box  VarParam:cons, lambda (s):seq:   set  VarParam:s to box  VarParam:s,applicTP   lambda (s->l-loop):seq:   set  VarParam:s->l-loop to box  VarParam:s->l-loop,Boxset  lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGetapplicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool symbol:whatever varfree:string-ref varfree:string-length varfree:< varfree:- varfree:cons
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
push rax
; varfree:-
mov rax, qword[fvar_tbl + WORD_SIZE*55 ]
push rax
; varfree:<
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
; varfree:string-length
mov rax, qword[fvar_tbl + WORD_SIZE*9 ]
push rax
; varfree:string-ref
mov rax, qword[fvar_tbl + WORD_SIZE*10 ]
push rax
push 5
; lambda (string-ref string-length < - cons):seq:   set  VarParam:string-ref to box  VarParam:string-ref, set  VarParam:string-length to box  VarParam:string-length, set  VarParam:< to box  VarParam:<, set  VarParam:- to box  VarParam:-, set  VarParam:cons to box  VarParam:cons, lambda (s):seq:   set  VarParam:s to box  VarParam:s,applicTP   lambda (s->l-loop):seq:   set  VarParam:s->l-loop to box  VarParam:s->l-loop,Boxset  lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGetapplicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool symbol:whatever

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode81)
jmp Lcont81
Lcode81:
push rbp
mov rbp, rsp
;seq:   set  VarParam:string-ref to box  VarParam:string-ref, set  VarParam:string-length to box  VarParam:string-length, set  VarParam:< to box  VarParam:<, set  VarParam:- to box  VarParam:-, set  VarParam:cons to box  VarParam:cons, lambda (s):seq:   set  VarParam:s to box  VarParam:s,applicTP   lambda (s->l-loop):seq:   set  VarParam:s->l-loop to box  VarParam:s->l-loop,Boxset  lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGetapplicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool symbol:whatever
;box  VarParam:string-ref,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:string-length,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:<,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:-,
mov rax, qword[rbp+8 * (4+3)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cons,
mov rax, qword[rbp+8 * (4+4)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (s):seq:   set  VarParam:s to box  VarParam:s,applicTP   lambda (s->l-loop):seq:   set  VarParam:s->l-loop to box  VarParam:s->l-loop,Boxset  lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGetapplicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool symbol:whatever

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode82)
jmp Lcont82
Lcode82:
push rbp
mov rbp, rsp
;seq:   set  VarParam:s to box  VarParam:s,applicTP   lambda (s->l-loop):seq:   set  VarParam:s->l-loop to box  VarParam:s->l-loop,Boxset  lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGetapplicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool symbol:whatever
;box  VarParam:s,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (s->l-loop):seq:   set  VarParam:s->l-loop to box  VarParam:s->l-loop,Boxset  lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGetapplicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool symbol:whatever
;args
mov rax, const_tbl+23
push rax
push 1
;body
; lambda (s->l-loop):seq:   set  VarParam:s->l-loop to box  VarParam:s->l-loop,Boxset  lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGetapplicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode83)
jmp Lcont83
Lcode83:
push rbp
mov rbp, rsp
;seq:   set  VarParam:s->l-loop to box  VarParam:s->l-loop,Boxset  lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGetapplicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool
;box  VarParam:s->l-loop,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (n a):seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGet

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode84)
jmp Lcont84
Lcode84:
push rbp
mov rbp, rsp
;seq:   set  VarParam:n to box  VarParam:n, set  VarParam:a to box  VarParam:a, if: applic  boxGetboxGet number 0,1then: boxGetelse applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGet
;box  VarParam:n,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:a,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet number 0,1
mov rax, const_tbl+34
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse85

                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 jmp Lexit85
 Lelse85:
                    ;applicTP  boxGetapplic  boxGetboxGet number 1,1applic  boxGetapplic  boxGetboxGetboxGetboxGet
;args
;applic  boxGetapplic  boxGetboxGetboxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
;applic  boxGetboxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*4]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGet number 1,1
mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit85:
leave
ret
Lcont84:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool
;args
push 0
;body
; lambda ():applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode86)
jmp Lcont86
Lcode86:
push rbp
mov rbp, rsp
;applicTP  boxGetapplic  boxGetapplic  boxGetboxGet number 1,1nil|bool
;args
mov rax, const_tbl+1
push rax
;applic  boxGetapplic  boxGetboxGet number 1,1
mov rax, const_tbl+51
push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*2]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont86:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 2
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont83:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont82:

leave
ret
Lcont81:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*58], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;def equal?
;applic   lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer):seq:   set  VarParam:= to box  VarParam:=, set  VarParam:string->list to box  VarParam:string->list, set  VarParam:rational? to box  VarParam:rational?, set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:pair? to box  VarParam:pair?, set  VarParam:char? to box  VarParam:char?, set  VarParam:string? to box  VarParam:string?, set  VarParam:eq? to box  VarParam:eq?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:char->integer to box  VarParam:char->integer,applicTP   lambda (equal?-loop):seq:   set  VarParam:equal?-loop to box  VarParam:equal?-loop,Boxset  lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse applicTP  boxGetboxGetboxGetapplicTP   lambda ():boxGet symbol:whatever varfree:= varfree:string->list varfree:rational? varfree:flonum? varfree:pair? varfree:char? varfree:string? varfree:eq? varfree:car varfree:cdr varfree:char->integer
; varfree:char->integer
mov rax, qword[fvar_tbl + WORD_SIZE*14 ]
push rax
; varfree:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*27 ]
push rax
; varfree:car
mov rax, qword[fvar_tbl + WORD_SIZE*26 ]
push rax
; varfree:eq?
mov rax, qword[fvar_tbl + WORD_SIZE*17 ]
push rax
; varfree:string?
mov rax, qword[fvar_tbl + WORD_SIZE*6 ]
push rax
; varfree:char?
mov rax, qword[fvar_tbl + WORD_SIZE*5 ]
push rax
; varfree:pair?
mov rax, qword[fvar_tbl + WORD_SIZE*3 ]
push rax
; varfree:flonum?
mov rax, qword[fvar_tbl + WORD_SIZE*1 ]
push rax
; varfree:rational?
mov rax, qword[fvar_tbl + WORD_SIZE*2 ]
push rax
; varfree:string->list
mov rax, qword[fvar_tbl + WORD_SIZE*58 ]
push rax
; varfree:=
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
push 11
; lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer):seq:   set  VarParam:= to box  VarParam:=, set  VarParam:string->list to box  VarParam:string->list, set  VarParam:rational? to box  VarParam:rational?, set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:pair? to box  VarParam:pair?, set  VarParam:char? to box  VarParam:char?, set  VarParam:string? to box  VarParam:string?, set  VarParam:eq? to box  VarParam:eq?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:char->integer to box  VarParam:char->integer,applicTP   lambda (equal?-loop):seq:   set  VarParam:equal?-loop to box  VarParam:equal?-loop,Boxset  lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse applicTP  boxGetboxGetboxGetapplicTP   lambda ():boxGet symbol:whatever

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode87)
jmp Lcont87
Lcode87:
push rbp
mov rbp, rsp
;seq:   set  VarParam:= to box  VarParam:=, set  VarParam:string->list to box  VarParam:string->list, set  VarParam:rational? to box  VarParam:rational?, set  VarParam:flonum? to box  VarParam:flonum?, set  VarParam:pair? to box  VarParam:pair?, set  VarParam:char? to box  VarParam:char?, set  VarParam:string? to box  VarParam:string?, set  VarParam:eq? to box  VarParam:eq?, set  VarParam:car to box  VarParam:car, set  VarParam:cdr to box  VarParam:cdr, set  VarParam:char->integer to box  VarParam:char->integer,applicTP   lambda (equal?-loop):seq:   set  VarParam:equal?-loop to box  VarParam:equal?-loop,Boxset  lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse applicTP  boxGetboxGetboxGetapplicTP   lambda ():boxGet symbol:whatever
;box  VarParam:=,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:string->list,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:rational?,
mov rax, qword[rbp+8 * (4+2)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:flonum?,
mov rax, qword[rbp+8 * (4+3)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:pair?,
mov rax, qword[rbp+8 * (4+4)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:char?,
mov rax, qword[rbp+8 * (4+5)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+5)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:string?,
mov rax, qword[rbp+8 * (4+6)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+6)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:eq?,
mov rax, qword[rbp+8 * (4+7)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+7)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:car,
mov rax, qword[rbp+8 * (4+8)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+8)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:cdr,
mov rax, qword[rbp+8 * (4+9)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+9)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:char->integer,
mov rax, qword[rbp+8 * (4+10)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+10)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda (equal?-loop):seq:   set  VarParam:equal?-loop to box  VarParam:equal?-loop,Boxset  lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse applicTP  boxGetboxGetboxGetapplicTP   lambda ():boxGet symbol:whatever
;args
mov rax, const_tbl+23
push rax
push 1
;body
; lambda (equal?-loop):seq:   set  VarParam:equal?-loop to box  VarParam:equal?-loop,Boxset  lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse applicTP  boxGetboxGetboxGetapplicTP   lambda ():boxGet

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode88)
jmp Lcont88
Lcode88:
push rbp
mov rbp, rsp
;seq:   set  VarParam:equal?-loop to box  VarParam:equal?-loop,Boxset  lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse applicTP  boxGetboxGetboxGetapplicTP   lambda ():boxGet
;box  VarParam:equal?-loop,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

; lambda (x y):seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse applicTP  boxGetboxGetboxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode89)
jmp Lcont89
Lcode89:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, set  VarParam:y to box  VarParam:y, if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetboxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen:  if: applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGetthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse nil|boolelse  if:  if: applic  boxGetboxGetthen: applic  boxGetboxGetelse nil|boolthen: applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGetelse applicTP  boxGetboxGetboxGet
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;box  VarParam:y,
mov rax, qword[rbp+8 * (4+1)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse100

                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 jmp Lexit100
 Lelse100:
                    mov rax, const_tbl+2
 Lexit100:
 cmp rax, SOB_FALSE_ADDRESS
 je Lelse90

                    ;applicTP  boxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit90
 Lelse90:
                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse99

                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 jmp Lexit99
 Lelse99:
                    mov rax, const_tbl+2
 Lexit99:
 cmp rax, SOB_FALSE_ADDRESS
 je Lelse91

                    ;applicTP  boxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit91
 Lelse91:
                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*5]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse98

                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*5]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 jmp Lexit98
 Lelse98:
                    mov rax, const_tbl+2
 Lexit98:
 cmp rax, SOB_FALSE_ADDRESS
 je Lelse92

                    ;applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*10]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*10]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit92
 Lelse92:
                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*4]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse97

                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*4]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 jmp Lexit97
 Lelse97:
                    mov rax, const_tbl+2
 Lexit97:
 cmp rax, SOB_FALSE_ADDRESS
 je Lelse93

                    ;applic  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*8]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*8]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse96

                    ;applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*9]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*9]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit96
 Lelse96:
                    mov rax, const_tbl+2
 Lexit96:
 jmp Lexit93
 Lelse93:
                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*6]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 je Lelse95

                    ;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*6]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 jmp Lexit95
 Lelse95:
                    mov rax, const_tbl+2
 Lexit95:
 cmp rax, SOB_FALSE_ADDRESS
 je Lelse94

                    ;applicTP  boxGetapplic  boxGetboxGetapplic  boxGetboxGet
;args
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
;applic  boxGetboxGet
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 jmp Lexit94
 Lelse94:
                    ;applicTP  boxGetboxGetboxGet
;args
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*1]
                                        mov rax, qword[rax+8*7]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit94:
 Lexit93:
 Lexit92:
 Lexit91:
 Lexit90:
leave
ret
Lcont89:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS

;applicTP   lambda ():boxGet
;args
push 0
;body
; lambda ():boxGet

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode101)
jmp Lcont101
Lcode101:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rax+8*0]
                                        mov rax, qword[rax+8*0]
                        mov rax,qword[rax]
                        
leave
ret
Lcont101:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 2
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont88:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont87:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

mov qword [fvar_tbl + WORD_SIZE*56], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic   varfree:map lambda (x):seq:   set  VarParam:x to box  VarParam:x,applicTP   varfree:applyboxGet Pair:applic   lambda ():applicTP   varfree:cons lambda (a):seq:   set  VarParam:a to box  VarParam:a, number 1,1applic   varfree:cons lambda (b):seq:   set  VarParam:b to box  VarParam:b, number 2,1applic   varfree:cons lambda (c):seq:   set  VarParam:c to box  VarParam:c, number 3,1applic   varfree:cons lambda (d):seq:   set  VarParam:d to box  VarParam:d, number 4,1applic   varfree:cons lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   lambda ():applicTP   varfree:cons lambda (a):seq:   set  VarParam:a to box  VarParam:a, number 1,1applic   varfree:cons lambda (b):seq:   set  VarParam:b to box  VarParam:b, number 2,1applic   varfree:cons lambda (c):seq:   set  VarParam:c to box  VarParam:c, number 3,1applic   varfree:cons lambda (d):seq:   set  VarParam:d to box  VarParam:d, number 4,1applic   varfree:cons lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
push 0
; lambda ():applicTP   varfree:cons lambda (a):seq:   set  VarParam:a to box  VarParam:a, number 1,1applic   varfree:cons lambda (b):seq:   set  VarParam:b to box  VarParam:b, number 2,1applic   varfree:cons lambda (c):seq:   set  VarParam:c to box  VarParam:c, number 3,1applic   varfree:cons lambda (d):seq:   set  VarParam:d to box  VarParam:d, number 4,1applic   varfree:cons lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode102)
jmp Lcont102
Lcode102:
push rbp
mov rbp, rsp
;applicTP   varfree:cons lambda (a):seq:   set  VarParam:a to box  VarParam:a, number 1,1applic   varfree:cons lambda (b):seq:   set  VarParam:b to box  VarParam:b, number 2,1applic   varfree:cons lambda (c):seq:   set  VarParam:c to box  VarParam:c, number 3,1applic   varfree:cons lambda (d):seq:   set  VarParam:d to box  VarParam:d, number 4,1applic   varfree:cons lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;args
;applic   varfree:cons lambda (b):seq:   set  VarParam:b to box  VarParam:b, number 2,1applic   varfree:cons lambda (c):seq:   set  VarParam:c to box  VarParam:c, number 3,1applic   varfree:cons lambda (d):seq:   set  VarParam:d to box  VarParam:d, number 4,1applic   varfree:cons lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (c):seq:   set  VarParam:c to box  VarParam:c, number 3,1applic   varfree:cons lambda (d):seq:   set  VarParam:d to box  VarParam:d, number 4,1applic   varfree:cons lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (d):seq:   set  VarParam:d to box  VarParam:d, number 4,1applic   varfree:cons lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
;applic   varfree:cons lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1nil|bool
mov rax, const_tbl+1
push rax
; lambda (z):seq:   set  VarParam:z to box  VarParam:z, number 26,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode103)
jmp Lcont103
Lcode103:
push rbp
mov rbp, rsp
;seq:   set  VarParam:z to box  VarParam:z, number 26,1
;box  VarParam:z,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+510
leave
ret
Lcont103:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (y):seq:   set  VarParam:y to box  VarParam:y, number 25,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode104)
jmp Lcont104
Lcode104:
push rbp
mov rbp, rsp
;seq:   set  VarParam:y to box  VarParam:y, number 25,1
;box  VarParam:y,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+493
leave
ret
Lcont104:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (x):seq:   set  VarParam:x to box  VarParam:x, number 24,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode105)
jmp Lcont105
Lcode105:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x, number 24,1
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+476
leave
ret
Lcont105:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (w):seq:   set  VarParam:w to box  VarParam:w, number 23,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode106)
jmp Lcont106
Lcode106:
push rbp
mov rbp, rsp
;seq:   set  VarParam:w to box  VarParam:w, number 23,1
;box  VarParam:w,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+459
leave
ret
Lcont106:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (v):seq:   set  VarParam:v to box  VarParam:v, number 22,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode107)
jmp Lcont107
Lcode107:
push rbp
mov rbp, rsp
;seq:   set  VarParam:v to box  VarParam:v, number 22,1
;box  VarParam:v,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+442
leave
ret
Lcont107:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (u):seq:   set  VarParam:u to box  VarParam:u, number 21,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode108)
jmp Lcont108
Lcode108:
push rbp
mov rbp, rsp
;seq:   set  VarParam:u to box  VarParam:u, number 21,1
;box  VarParam:u,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+425
leave
ret
Lcont108:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (t):seq:   set  VarParam:t to box  VarParam:t, number 20,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode109)
jmp Lcont109
Lcode109:
push rbp
mov rbp, rsp
;seq:   set  VarParam:t to box  VarParam:t, number 20,1
;box  VarParam:t,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+408
leave
ret
Lcont109:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (s):seq:   set  VarParam:s to box  VarParam:s, number 19,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode110)
jmp Lcont110
Lcode110:
push rbp
mov rbp, rsp
;seq:   set  VarParam:s to box  VarParam:s, number 19,1
;box  VarParam:s,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+391
leave
ret
Lcont110:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (r):seq:   set  VarParam:r to box  VarParam:r, number 18,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode111)
jmp Lcont111
Lcode111:
push rbp
mov rbp, rsp
;seq:   set  VarParam:r to box  VarParam:r, number 18,1
;box  VarParam:r,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+374
leave
ret
Lcont111:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (q):seq:   set  VarParam:q to box  VarParam:q, number 17,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode112)
jmp Lcont112
Lcode112:
push rbp
mov rbp, rsp
;seq:   set  VarParam:q to box  VarParam:q, number 17,1
;box  VarParam:q,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+357
leave
ret
Lcont112:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (p):seq:   set  VarParam:p to box  VarParam:p, number 16,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode113)
jmp Lcont113
Lcode113:
push rbp
mov rbp, rsp
;seq:   set  VarParam:p to box  VarParam:p, number 16,1
;box  VarParam:p,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+340
leave
ret
Lcont113:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (o):seq:   set  VarParam:o to box  VarParam:o, number 15,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode114)
jmp Lcont114
Lcode114:
push rbp
mov rbp, rsp
;seq:   set  VarParam:o to box  VarParam:o, number 15,1
;box  VarParam:o,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+323
leave
ret
Lcont114:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (n):seq:   set  VarParam:n to box  VarParam:n, number 14,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode115)
jmp Lcont115
Lcode115:
push rbp
mov rbp, rsp
;seq:   set  VarParam:n to box  VarParam:n, number 14,1
;box  VarParam:n,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+306
leave
ret
Lcont115:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (m):seq:   set  VarParam:m to box  VarParam:m, number 13,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode116)
jmp Lcont116
Lcode116:
push rbp
mov rbp, rsp
;seq:   set  VarParam:m to box  VarParam:m, number 13,1
;box  VarParam:m,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+289
leave
ret
Lcont116:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (l):seq:   set  VarParam:l to box  VarParam:l, number 12,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode117)
jmp Lcont117
Lcode117:
push rbp
mov rbp, rsp
;seq:   set  VarParam:l to box  VarParam:l, number 12,1
;box  VarParam:l,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+272
leave
ret
Lcont117:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (k):seq:   set  VarParam:k to box  VarParam:k, number 11,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode118)
jmp Lcont118
Lcode118:
push rbp
mov rbp, rsp
;seq:   set  VarParam:k to box  VarParam:k, number 11,1
;box  VarParam:k,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+255
leave
ret
Lcont118:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (j):seq:   set  VarParam:j to box  VarParam:j, number 10,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode119)
jmp Lcont119
Lcode119:
push rbp
mov rbp, rsp
;seq:   set  VarParam:j to box  VarParam:j, number 10,1
;box  VarParam:j,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+238
leave
ret
Lcont119:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (i):seq:   set  VarParam:i to box  VarParam:i, number 9,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode120)
jmp Lcont120
Lcode120:
push rbp
mov rbp, rsp
;seq:   set  VarParam:i to box  VarParam:i, number 9,1
;box  VarParam:i,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+221
leave
ret
Lcont120:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (h):seq:   set  VarParam:h to box  VarParam:h, number 8,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode121)
jmp Lcont121
Lcode121:
push rbp
mov rbp, rsp
;seq:   set  VarParam:h to box  VarParam:h, number 8,1
;box  VarParam:h,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+204
leave
ret
Lcont121:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (g):seq:   set  VarParam:g to box  VarParam:g, number 7,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode122)
jmp Lcont122
Lcode122:
push rbp
mov rbp, rsp
;seq:   set  VarParam:g to box  VarParam:g, number 7,1
;box  VarParam:g,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+187
leave
ret
Lcont122:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (f):seq:   set  VarParam:f to box  VarParam:f, number 6,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode123)
jmp Lcont123
Lcode123:
push rbp
mov rbp, rsp
;seq:   set  VarParam:f to box  VarParam:f, number 6,1
;box  VarParam:f,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+170
leave
ret
Lcont123:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (e):seq:   set  VarParam:e to box  VarParam:e, number 5,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode124)
jmp Lcont124
Lcode124:
push rbp
mov rbp, rsp
;seq:   set  VarParam:e to box  VarParam:e, number 5,1
;box  VarParam:e,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+153
leave
ret
Lcont124:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (d):seq:   set  VarParam:d to box  VarParam:d, number 4,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode125)
jmp Lcont125
Lcode125:
push rbp
mov rbp, rsp
;seq:   set  VarParam:d to box  VarParam:d, number 4,1
;box  VarParam:d,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+136
leave
ret
Lcont125:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (c):seq:   set  VarParam:c to box  VarParam:c, number 3,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode126)
jmp Lcont126
Lcode126:
push rbp
mov rbp, rsp
;seq:   set  VarParam:c to box  VarParam:c, number 3,1
;box  VarParam:c,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+119
leave
ret
Lcont126:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (b):seq:   set  VarParam:b to box  VarParam:b, number 2,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode127)
jmp Lcont127
Lcode127:
push rbp
mov rbp, rsp
;seq:   set  VarParam:b to box  VarParam:b, number 2,1
;box  VarParam:b,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+102
leave
ret
Lcont127:

push rax
push 2
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (a):seq:   set  VarParam:a to box  VarParam:a, number 1,1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode128)
jmp Lcont128
Lcode128:
push rbp
mov rbp, rsp
;seq:   set  VarParam:a to box  VarParam:a, number 1,1
;box  VarParam:a,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

mov rax, const_tbl+51
leave
ret
Lcont128:

push rax
push 2
;body
; varfree:cons
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont102:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
; lambda (x):seq:   set  VarParam:x to box  VarParam:x,applicTP   varfree:applyboxGet Pair:

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode129)
jmp Lcont129
Lcode129:
push rbp
mov rbp, rsp
;seq:   set  VarParam:x to box  VarParam:x,applicTP   varfree:applyboxGet Pair:
;box  VarParam:x,
mov rax, qword[rbp+8 * (4+0)]
push rax
MALLOC rax, 8
pop qword[rax]

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

;applicTP   varfree:applyboxGet Pair:
;args
mov rax, const_tbl+85
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
;body
; varfree:apply
mov rax, qword[fvar_tbl + WORD_SIZE*31 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont129:

push rax
push 2
; varfree:map
mov rax, qword[fvar_tbl + WORD_SIZE*68 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

 car:
    push rbp
    mov rbp, rsp
    mov rbx, PVAR(0)
    CAR rax, rbx
    pop rbp
    ret

  cdr:
    push rbp
    mov rbp, rsp
    mov rbx, PVAR(0)
    CDR rax, rbx
    pop rbp
    ret

  cons:
    push rbp
    mov rbp, rsp
    mov rbx, PVAR(0)
    mov rcx, PVAR(1)
    MAKE_PAIR(rax, rbx, rcx)
    pop rbp
    ret

  set_car:
    push rbp
    mov rbp, rsp
    mov rbx, PVAR(0)
    mov rcx, PVAR(1)
    mov [rbx + TYPE_SIZE], rcx
    mov rax, T_VOID
    pop rbp
    ret

  set_cdr:
    push rbp
    mov rbp, rsp
    mov rbx, PVAR(0)
    mov rcx, PVAR(1)
    mov [rbx + WORD_SIZE +TYPE_SIZE], rcx
    mov rax, T_VOID
    pop rbp
    ret

  apply:
    push rbp
    mov rbp, rsp
    mov rax, [rbp + 8 * 3]      ; rax = argc
    dec rax
    mov rax, PVAR(rax)          ; rax = last arg = list
    xor rdx, rdx                ; rdx = list_size

    push_args:
      cmp byte[rax], T_NIL
      je end_push_args
      CAR rbx, rax              ; rbx = car
      push rbx
      CDR rax, rax              ; rax = cdr
      inc rdx
      jmp push_args
    end_push_args:

    mov rsi, rdx                  ; rsi = list_size backup
    mov rcx, 0                    ; i = 0
    mov rbx, rdx                  ; rbx = list_size
    shr rbx, 1                    ; rbx = list_size/2
    dec rdx                       ; rdx = list_size -1

    _revert_args:
      cmp rcx, rbx
      jae end_revert_args
      mov rax, [rsp + 8 * (rdx)]  ; rax = [rsp + 8*(list_size - i -1)]
      mov rdi,[rsp+8*rcx]
      mov [rsp + 8 * rdx], rdi
      mov [rsp + 8 * rcx],  rax
      dec rdx
      inc rcx
      jmp _revert_args
    end_revert_args:

    mov rax, [rbp + 8 * 3]      ;rax = argc
    mov rdi, rax                ;rdi = index
    add rdi, 2
    push_objs:
      cmp rdi, 4
      jbe end_push_objs
      push qword [rbp + 8 * rdi]
      inc rsi
      dec rdi
      jmp push_objs
    end_push_objs:

    push rsi                    ;push number of args
    mov rax, PVAR(0)            ;rax = closure of the procedure
    CLOSURE_ENV rbx, rax
    push rbx
    CLOSURE_CODE rbx, rax
    call rbx
    add rsp, 8 * 1
    pop rbx
    shl rbx, 3
    add rsp, rbx
    pop rbx

    pop rbp
    ret