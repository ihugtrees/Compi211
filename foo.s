;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 69

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(-1,1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+WORD_SIZE*0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+WORD_SIZE*61], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+WORD_SIZE*60], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+WORD_SIZE*3], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+WORD_SIZE*4], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+WORD_SIZE*5], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+WORD_SIZE*6], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+WORD_SIZE*7], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+WORD_SIZE*8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+WORD_SIZE*9], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+WORD_SIZE*10], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+WORD_SIZE*11], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+WORD_SIZE*12], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+WORD_SIZE*13], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+WORD_SIZE*14], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+WORD_SIZE*15], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+WORD_SIZE*36], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+WORD_SIZE*16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+WORD_SIZE*17], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+WORD_SIZE*18], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+WORD_SIZE*20], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+WORD_SIZE*22], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+WORD_SIZE*21], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+WORD_SIZE*35], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+WORD_SIZE*47], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+WORD_SIZE*43], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;def map
;applic   lambda  set  set  set  set  set applicTP   lambda  set  set Boxset Boxset applicTP   lambda lambdaOptapplicTP   symbol:whatever symbol:whatever var:null? var:car var:cdr var:cons var:apply
; var:apply
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
push rax
; var:cons
mov rax, qword[fvar_tbl + WORD_SIZE*23 ]
push rax
; var:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
; var:car
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 5
; lambda  set  set  set  set  set applicTP   lambda  set  set Boxset Boxset applicTP   lambda lambdaOptapplicTP   symbol:whatever symbol:whatever

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode1)
jmp Lcont1
Lcode1:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+3)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+4)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set  set Boxset Boxset applicTP   lambda lambdaOptapplicTP   symbol:whatever symbol:whatever
mov rax, const_tbl+23
push rax
mov rax, const_tbl+23
push rax
push 2
; lambda  set  set Boxset Boxset applicTP   lambda lambdaOptapplicTP  

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode2)
jmp Lcont2
Lcode2:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set  set  if: applic  applic  then:elseapplicTP  applic  applic  applic  applic  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode3)
jmp Lcont3
Lcode3:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  applic  
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse4

                    mov rax, const_tbl+1
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit4
 Lelse4:
                    mov rax, const_tbl+1
 Lexit4:

leave
ret
Lcont3:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
; lambda  set  set  if: applic  then:elseapplicTP  applic  applic  applic  applic  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode5)
jmp Lcont5
Lcode5:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse6

                    mov rax, const_tbl+1
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit6
 Lelse6:
                    mov rax, const_tbl+1
 Lexit6:

leave
ret
Lcont5:


                              push rax

                              mov rax, qword[rbp+8 * (4+1)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda lambdaOptapplicTP  
push 0
; lambda lambdaOptapplicTP  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode7)
jmp Lcont7
Lcode7:
push rbp
mov rbp, rsp
; lambdaOptapplicTP  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode8)
jmp Lcont8
Lcode8:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
;applicTP  
mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont8:

leave
ret
Lcont7:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont2:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont1:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*37], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def fold-left
; lambda  set  set  set  if: applic   var:equal?then:elseapplicTP   var:fold-leftapplic  applic   var:carapplic   var:cdr

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode9)
jmp Lcont9
Lcode9:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic   var:equal?
mov rax, const_tbl+1
push rax
mov rax, qword[rbp+8 * (4+2)]
                        mov rax,qword[rax]
                        
push rax
push 2
; var:equal?
mov rax, qword[fvar_tbl + WORD_SIZE*57 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse10

                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit10
 Lelse10:
                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 Lexit10:

leave
ret
Lcont9:

              mov qword [fvar_tbl + WORD_SIZE*50], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def fold-right
; lambda  set  set  set  if: applic   var:equal?then:elseapplicTP  applic   var:carapplic   var:fold-rightapplic   var:cdr

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode11)
jmp Lcont11
Lcode11:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic   var:equal?
mov rax, const_tbl+1
push rax
mov rax, qword[rbp+8 * (4+2)]
                        mov rax,qword[rax]
                        
push rax
push 2
; var:equal?
mov rax, qword[fvar_tbl + WORD_SIZE*57 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse12

                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit12
 Lelse12:
                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 Lexit12:

leave
ret
Lcont11:

              mov qword [fvar_tbl + WORD_SIZE*31], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def cons*
; lambdaOpt  set  if: applic   var:null?applic   var:cdrthen:applicTP   var:carelseapplicTP   var:consapplic   var:carapplic   var:apply var:cons*applic   var:cdr

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode13)
jmp Lcont13
Lcode13:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic   var:null?applic   var:cdr
;applic   var:cdr
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
; var:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse14

                    ;applicTP   var:car
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
; var:car
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit14
 Lelse14:
                    ;applicTP   var:car
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
; var:car
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit14:

leave
ret
Lcont13:

              mov qword [fvar_tbl + WORD_SIZE*29], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def append
;applic   lambda  set  set  set  lambdaOpt  set applicTP   lambda  set  set  if: applic  then:elseapplicTP   var:null? var:fold-right var:cons
; var:cons
mov rax, qword[fvar_tbl + WORD_SIZE*23 ]
push rax
; var:fold-right
mov rax, qword[fvar_tbl + WORD_SIZE*31 ]
push rax
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3
; lambda  set  set  set  lambdaOpt  set applicTP   lambda  set  set  if: applic  then:elseapplicTP  

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode15)
jmp Lcont15
Lcode15:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambdaOpt  set applicTP   lambda  set  set  if: applic  then:elseapplicTP  

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode16)
jmp Lcont16
Lcode16:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set  set  if: applic  then:elseapplicTP  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+1
push rax
; lambda  set  set  if: applic  then:elseapplicTP  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode17)
jmp Lcont17
Lcode17:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse18

                    mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit18
 Lelse18:
                    mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 Lexit18:

leave
ret
Lcont17:

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 6
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont16:


leave
ret
Lcont15:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*30], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def list
; lambdaOpt  set 

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode19)
jmp Lcont19
Lcode19:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        

leave
ret
Lcont19:

              mov qword [fvar_tbl + WORD_SIZE*32], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def list?
;applic   lambda  set  set  set applicTP   lambda  set Boxset applicTP   lambda symbol:whatever var:null? var:pair? var:cdr
; var:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
; var:pair?
mov rax, qword[fvar_tbl + WORD_SIZE*3 ]
push rax
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3
; lambda  set  set  set applicTP   lambda  set Boxset applicTP   lambda symbol:whatever

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode20)
jmp Lcont20
Lcode20:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set Boxset applicTP   lambda symbol:whatever
mov rax, const_tbl+23
push rax
push 1
; lambda  set Boxset applicTP   lambda

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode21)
jmp Lcont21
Lcode21:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set  applic   if: applic  then:applicTP   var:list?applic  else

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode22)
jmp Lcont22
Lcode22:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit23
    ;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse24

                    ;applicTP   var:list?applic  
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
; var:list?
mov rax, qword[fvar_tbl + WORD_SIZE*33 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit24
 Lelse24:
                    ;applicTP   var:list?applic  
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
; var:list?
mov rax, qword[fvar_tbl + WORD_SIZE*33 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit24:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit23
    
Lexit23:

leave
ret
Lcont22:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda
push 0
; lambda

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode25)
jmp Lcont25
Lcode25:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
leave
ret
Lcont25:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont21:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont20:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*33], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def make-string
;applic   lambda  set  set  set  lambdaOpt  set  set  if: applic  then:applicTP   charelseapplicTP  applic   var:null? var:car var:make-string
; var:make-string
mov rax, qword[fvar_tbl + WORD_SIZE*12 ]
push rax
; var:car
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3
; lambda  set  set  set  lambdaOpt  set  set  if: applic  then:applicTP   charelseapplicTP  applic  

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode26)
jmp Lcont26
Lcode26:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambdaOpt  set  set  if: applic  then:applicTP   charelseapplicTP  applic  

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode27)
jmp Lcont27
Lcode27:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse28

                    ;applicTP   char
mov rax, const_tbl+32
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit28
 Lelse28:
                    ;applicTP   char
mov rax, const_tbl+32
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit28:

leave
ret
Lcont27:


leave
ret
Lcont26:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*12], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def not
; lambda  set  if: then:else

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode29)
jmp Lcont29
Lcode29:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse30

                    mov rax, const_tbl+2
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit30
 Lelse30:
                    mov rax, const_tbl+2
 Lexit30:

leave
ret
Lcont29:

              mov qword [fvar_tbl + WORD_SIZE*42], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;applic   lambda  set  set  set  set  set  set  set  set  set  set  set  set  set applicTP   lambda  set applic   lambda  set Boxset +Boxset *Boxset / lambda  set  if: applic  then:elseapplicTP   lambda  set applicTP  applic  applic   var:numeratorapplic  applic   var:denominatorapplic   var:gcdapplic   var:numeratorapplic   var:denominatorapplicTP   lambda  set Boxset =Boxset < lambda  set  lambdaOpt  set  set applicTP   lambda  set  set  if: then:elseapplic   lambda  set applicTP   lambda  set  lambda  set  set  if:  if: applic  then:applic  elsethen:applicTP  applic  else if:  if: applic  then:applic  elsethen:applicTP  applic  elseapplicTP   var:flonum? var:rational? var:exact->inexact var:fold-left var:map var:+ var:* var:/ var:= var:< var:car var:cdr var:null?
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
; var:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
; var:car
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
; var:<
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
; var:=
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
; var:/
mov rax, qword[fvar_tbl + WORD_SIZE*20 ]
push rax
; var:*
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
push rax
; var:+
mov rax, qword[fvar_tbl + WORD_SIZE*17 ]
push rax
; var:map
mov rax, qword[fvar_tbl + WORD_SIZE*37 ]
push rax
; var:fold-left
mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
push rax
; var:exact->inexact
mov rax, qword[fvar_tbl + WORD_SIZE*36 ]
push rax
; var:rational?
mov rax, qword[fvar_tbl + WORD_SIZE*60 ]
push rax
; var:flonum?
mov rax, qword[fvar_tbl + WORD_SIZE*61 ]
push rax
push 13
; lambda  set  set  set  set  set  set  set  set  set  set  set  set  set applicTP   lambda  set applic   lambda  set Boxset +Boxset *Boxset / lambda  set  if: applic  then:elseapplicTP   lambda  set applicTP  applic  applic   var:numeratorapplic  applic   var:denominatorapplic   var:gcdapplic   var:numeratorapplic   var:denominatorapplicTP   lambda  set Boxset =Boxset < lambda  set  lambdaOpt  set  set applicTP   lambda  set  set  if: then:elseapplic   lambda  set applicTP   lambda  set  lambda  set  set  if:  if: applic  then:applic  elsethen:applicTP  applic  else if:  if: applic  then:applic  elsethen:applicTP  applic  elseapplicTP  

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode31)
jmp Lcont31
Lcode31:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+3)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+4)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+5)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+5)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+6)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+6)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+7)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+7)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+8)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+8)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+9)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+9)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+10)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+10)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+11)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+11)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+12)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+12)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set applic   lambda  set Boxset +Boxset *Boxset / lambda  set  if: applic  then:elseapplicTP   lambda  set applicTP  applic  applic   var:numeratorapplic  applic   var:denominatorapplic   var:gcdapplic   var:numeratorapplic   var:denominatorapplicTP   lambda  set Boxset =Boxset < lambda  set  lambdaOpt  set  set applicTP   lambda  set  set  if: then:elseapplic   lambda  set applicTP   lambda  set  lambda  set  set  if:  if: applic  then:applic  elsethen:applicTP  applic  else if:  if: applic  then:applic  elsethen:applicTP  applic  elseapplicTP  
; lambda  set  lambda  set  set  if:  if: applic  then:applic  elsethen:applicTP  applic  else if:  if: applic  then:applic  elsethen:applicTP  applic  elseapplicTP  

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode47)
jmp Lcont47
Lcode47:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set  set  if:  if: applic  then:applic  elsethen:applicTP  applic  else if:  if: applic  then:applic  elsethen:applicTP  applic  elseapplicTP  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode48)
jmp Lcont48
Lcode48:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse50

                    ;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit50
 Lelse50:
                    ;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 Lexit50:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse49

                    ;applicTP  applic  
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit49
 Lelse49:
                    ;applicTP  applic  
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit49:

leave
ret
Lcont48:


leave
ret
Lcont47:

push rax
push 1
; lambda  set applic   lambda  set Boxset +Boxset *Boxset / lambda  set  if: applic  then:elseapplicTP   lambda  set applicTP  applic  applic   var:numeratorapplic  applic   var:denominatorapplic   var:gcdapplic   var:numeratorapplic   var:denominatorapplicTP   lambda  set Boxset =Boxset < lambda  set  lambdaOpt  set  set applicTP   lambda  set  set  if: then:elseapplic   lambda  set applicTP  

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode32)
jmp Lcont32
Lcode32:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic   lambda  set Boxset +Boxset *Boxset / lambda  set  if: applic  then:elseapplicTP   lambda  set applicTP  applic  applic   var:numeratorapplic  applic   var:denominatorapplic   var:gcdapplic   var:numeratorapplic   var:denominator
; lambda  set  if: applic  then:elseapplicTP   lambda  set applicTP  applic  applic   var:numeratorapplic  applic   var:denominatorapplic   var:gcdapplic   var:numeratorapplic   var:denominator

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode39)
jmp Lcont39
Lcode39:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse40

                    mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit40
 Lelse40:
                    mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 Lexit40:

leave
ret
Lcont39:

push rax
push 1
; lambda  set Boxset +Boxset *Boxset /

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode33)
jmp Lcont33
Lcode33:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambdaOpt  set applicTP  applic  applic   number

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode34)
jmp Lcont34
Lcode34:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP  applic  applic   number
;applic  applic   number
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+34
push rax
;applic  
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*5]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont34:


                              push rax

                              ; var:+
mov rax, qword[fvar_tbl + WORD_SIZE*17 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
; lambdaOpt  set applicTP  applic  applic   number

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode35)
jmp Lcont35
Lcode35:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP  applic  applic   number
;applic  applic   number
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+51
push rax
;applic  
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*6]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont35:


                              push rax

                              ; var:*
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
;applic   lambda  set  lambdaOpt  set  set  if: applic  then:applicTP   numberelseapplicTP  applic  applic  
;applic  
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*7]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
; lambda  set  lambdaOpt  set  set  if: applic  then:applicTP   numberelseapplicTP  applic  

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode36)
jmp Lcont36
Lcode36:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambdaOpt  set  set  if: applic  then:applicTP   numberelseapplicTP  applic  

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode37)
jmp Lcont37
Lcode37:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
                                        mov rax, qword[rbp+8*12]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse38

                    ;applicTP   number
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+51
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit38
 Lelse38:
                    ;applicTP   number
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+51
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit38:

leave
ret
Lcont37:


leave
ret
Lcont36:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args


                              push rax

                              ; var:/
mov rax, qword[fvar_tbl + WORD_SIZE*20 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS


leave
ret
Lcont33:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args
;applicTP   lambda  set Boxset =Boxset < lambda  set  lambdaOpt  set  set applicTP   lambda  set  set  if: then:elseapplic   lambda  set applicTP  
; lambda  set  lambdaOpt  set  set applicTP   lambda  set  set  if: then:elseapplic   lambda  set applicTP  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode42)
jmp Lcont42
Lcode42:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambdaOpt  set  set applicTP   lambda  set  set  if: then:elseapplic   lambda  set applicTP  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode43)
jmp Lcont43
Lcode43:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set  set  if: then:elseapplic   lambda  set applicTP  
;applic   lambda  set applicTP  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
; lambda  set applicTP  

CREATE_EXT_ENV 5
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode44)
jmp Lcont44
Lcode44:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont44:

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*4]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, const_tbl+4
push rax
; lambda  set  set  if: then:else

CREATE_EXT_ENV 5
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode45)
jmp Lcont45
Lcode45:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse46

                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit46
 Lelse46:
                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 Lexit46:

leave
ret
Lcont45:

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 6
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont43:


leave
ret
Lcont42:

push rax
push 1
; lambda  set Boxset =Boxset <

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode41)
jmp Lcont41
Lcode41:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  applic  
;applic  
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*8]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args


                              push rax

                              ; var:=
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
;applic  applic  
;applic  
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*9]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args


                              push rax

                              ; var:<
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS


leave
ret
Lcont41:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont32:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont31:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

	call write_sob_if_not_void

;def -
;applic   lambda  set  set  set  lambdaOpt  set  set  if: applic  then:applicTP   numberapplic   var:* numberelseapplicTP  applic   var:* numberapplic   var:apply var:+ var:null?
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
; var:+
mov rax, qword[fvar_tbl + WORD_SIZE*17 ]
push rax
; var:apply
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
push rax
push 3
; lambda  set  set  set  lambdaOpt  set  set  if: applic  then:applicTP   numberapplic   var:* numberelseapplicTP  applic   var:* numberapplic  

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode51)
jmp Lcont51
Lcode51:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambdaOpt  set  set  if: applic  then:applicTP   numberapplic   var:* numberelseapplicTP  applic   var:* numberapplic  

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode52)
jmp Lcont52
Lcode52:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse53

                    ;applicTP   numberapplic   var:* number
;applic   var:* number
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+68
push rax
push 2
; var:*
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, const_tbl+34
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit53
 Lelse53:
                    ;applicTP   numberapplic   var:* number
;applic   var:* number
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+68
push rax
push 2
; var:*
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, const_tbl+34
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit53:

leave
ret
Lcont52:


leave
ret
Lcont51:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*19], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def >
;applic   lambda  set  set  set  set  set  lambdaOpt  set  set applicTP   lambda  set  set  if: then:applicTP   applic  applic  else var:null? var:not var:< var:= var:fold-left
; var:fold-left
mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
push rax
; var:=
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
; var:<
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
; var:not
mov rax, qword[fvar_tbl + WORD_SIZE*42 ]
push rax
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 5
; lambda  set  set  set  set  set  lambdaOpt  set  set applicTP   lambda  set  set  if: then:applicTP   applic  applic  else

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode54)
jmp Lcont54
Lcode54:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+3)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+4)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambdaOpt  set  set applicTP   lambda  set  set  if: then:applicTP   applic  applic  else

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode55)
jmp Lcont55
Lcode55:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set  set  if: then:applicTP   applic  applic  else
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+4
push rax
; lambda  set  set  if: then:applicTP   applic  applic  else

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode56)
jmp Lcont56
Lcode56:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse57

                    ;applicTP   applic  applic  
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit59
    ;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit59
    
Lexit59:
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit57
 Lelse57:
                    ;applicTP   applic  applic  
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit58
    ;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*3]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit58
    
Lexit58:
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit57:

leave
ret
Lcont56:

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*4]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 6
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont55:


leave
ret
Lcont54:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*41], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def gcd
;applic   lambda  set  set  set  set applicTP   lambda  set Boxset applicTP   lambda lambdaOpt if: applic  then: numberelseapplicTP  applic  applic   symbol:whatever var:gcd var:null? var:car var:cdr
; var:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
; var:car
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
; var:null?
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
; var:gcd
mov rax, qword[fvar_tbl + WORD_SIZE*43 ]
push rax
push 4
; lambda  set  set  set  set applicTP   lambda  set Boxset applicTP   lambda lambdaOpt if: applic  then: numberelseapplicTP  applic  applic   symbol:whatever

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode60)
jmp Lcont60
Lcode60:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+3)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set Boxset applicTP   lambda lambdaOpt if: applic  then: numberelseapplicTP  applic  applic   symbol:whatever
mov rax, const_tbl+23
push rax
push 1
; lambda  set Boxset applicTP   lambda lambdaOpt if: applic  then: numberelseapplicTP  applic  applic  

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode61)
jmp Lcont61
Lcode61:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set  set  if: applic  then:elseapplicTP  applic  applic  applic  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode62)
jmp Lcont62
Lcode62:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse63

                    mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit63
 Lelse63:
                    mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
 Lexit63:

leave
ret
Lcont62:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda lambdaOpt if: applic  then: numberelseapplicTP  applic  applic  
push 0
; lambda lambdaOpt if: applic  then: numberelseapplicTP  applic  applic  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode64)
jmp Lcont64
Lcode64:
push rbp
mov rbp, rsp
; lambdaOpt if: applic  then: numberelseapplicTP  applic  applic  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode65)
jmp Lcont65
Lcode65:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
;applic  
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse66

                    mov rax, const_tbl+34
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit66
 Lelse66:
                    mov rax, const_tbl+34
 Lexit66:
leave
ret
Lcont65:

leave
ret
Lcont64:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont61:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont60:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*43], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def zero?
;applic   lambda  set  lambda  set applicTP   number var:=
; var:=
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
push 1
; lambda  set  lambda  set applicTP   number

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode67)
jmp Lcont67
Lcode67:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set applicTP   number

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode68)
jmp Lcont68
Lcode68:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   number
mov rax, const_tbl+34
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont68:


leave
ret
Lcont67:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*45], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def integer?
;applic   lambda  set  set  set  lambda  set  if: applic  then:applicTP  applic   numberelse var:rational? var:= var:denominator
; var:denominator
mov rax, qword[fvar_tbl + WORD_SIZE*47 ]
push rax
; var:=
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
; var:rational?
mov rax, qword[fvar_tbl + WORD_SIZE*60 ]
push rax
push 3
; lambda  set  set  set  lambda  set  if: applic  then:applicTP  applic   numberelse

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode69)
jmp Lcont69
Lcode69:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set  if: applic  then:applicTP  applic   numberelse

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode70)
jmp Lcont70
Lcode70:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse71

                    ;applicTP  applic   number
mov rax, const_tbl+51
push rax
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit71
 Lelse71:
                    ;applicTP  applic   number
mov rax, const_tbl+51
push rax
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit71:

leave
ret
Lcont70:


leave
ret
Lcont69:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*2], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def number?
;applic   lambda  set  set  lambda  set  applic  applicTP   var:flonum? var:rational?
; var:rational?
mov rax, qword[fvar_tbl + WORD_SIZE*60 ]
push rax
; var:flonum?
mov rax, qword[fvar_tbl + WORD_SIZE*61 ]
push rax
push 2
; lambda  set  set  lambda  set  applic  applicTP  

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode72)
jmp Lcont72
Lcode72:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set  applic  applicTP  

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode73)
jmp Lcont73
Lcode73:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit74
    ;applicTP  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit74
    
Lexit74:

leave
ret
Lcont73:


leave
ret
Lcont72:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*48], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def length
;applic   lambda  set  set  lambda  set applicTP   lambda  set  set applicTP   number number var:fold-left var:+
; var:+
mov rax, qword[fvar_tbl + WORD_SIZE*17 ]
push rax
; var:fold-left
mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
push rax
push 2
; lambda  set  set  lambda  set applicTP   lambda  set  set applicTP   number number

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode75)
jmp Lcont75
Lcode75:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set applicTP   lambda  set  set applicTP   number number

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode76)
jmp Lcont76
Lcode76:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set  set applicTP   number number
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
mov rax, const_tbl+34
push rax
; lambda  set  set applicTP   number

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode77)
jmp Lcont77
Lcode77:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   number
mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont77:

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 6
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont76:


leave
ret
Lcont75:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*49], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def string->list
;applic   lambda  set  set  set  set  set  lambda  set applicTP   lambda  set Boxset applicTP   lambdaapplicTP  applic  applic   number symbol:whatever var:string-ref var:string-length var:< var:- var:cons
; var:cons
mov rax, qword[fvar_tbl + WORD_SIZE*23 ]
push rax
; var:-
mov rax, qword[fvar_tbl + WORD_SIZE*19 ]
push rax
; var:<
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
; var:string-length
mov rax, qword[fvar_tbl + WORD_SIZE*9 ]
push rax
; var:string-ref
mov rax, qword[fvar_tbl + WORD_SIZE*10 ]
push rax
push 5
; lambda  set  set  set  set  set  lambda  set applicTP   lambda  set Boxset applicTP   lambdaapplicTP  applic  applic   number symbol:whatever

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode78)
jmp Lcont78
Lcode78:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+3)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+4)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set applicTP   lambda  set Boxset applicTP   lambdaapplicTP  applic  applic   number symbol:whatever

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode79)
jmp Lcont79
Lcode79:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set Boxset applicTP   lambdaapplicTP  applic  applic   number symbol:whatever
mov rax, const_tbl+23
push rax
push 1
; lambda  set Boxset applicTP   lambdaapplicTP  applic  applic   number

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode80)
jmp Lcont80
Lcode80:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set  set  if: applic   numberthen:elseapplicTP  applic   numberapplic  applic  

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode81)
jmp Lcont81
Lcode81:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic   number
mov rax, const_tbl+34
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse82

                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit82
 Lelse82:
                    mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
 Lexit82:

leave
ret
Lcont81:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambdaapplicTP  applic  applic   number
push 0
; lambdaapplicTP  applic  applic   number

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode83)
jmp Lcont83
Lcode83:
push rbp
mov rbp, rsp
;applicTP  applic  applic   number
mov rax, const_tbl+1
push rax
;applic  applic   number
mov rax, const_tbl+51
push rax
;applic  
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont83:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont80:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont79:


leave
ret
Lcont78:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*59], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

;def equal?
;applic   lambda  set  set  set  set  set  set  set  set  set  set  set applicTP   lambda  set Boxset applicTP   lambda symbol:whatever var:= var:string->list var:rational? var:flonum? var:pair? var:char? var:string? var:eq? var:car var:cdr var:char->integer
; var:char->integer
mov rax, qword[fvar_tbl + WORD_SIZE*14 ]
push rax
; var:cdr
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
; var:car
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
; var:eq?
mov rax, qword[fvar_tbl + WORD_SIZE*16 ]
push rax
; var:string?
mov rax, qword[fvar_tbl + WORD_SIZE*6 ]
push rax
; var:char?
mov rax, qword[fvar_tbl + WORD_SIZE*5 ]
push rax
; var:pair?
mov rax, qword[fvar_tbl + WORD_SIZE*3 ]
push rax
; var:flonum?
mov rax, qword[fvar_tbl + WORD_SIZE*61 ]
push rax
; var:rational?
mov rax, qword[fvar_tbl + WORD_SIZE*60 ]
push rax
; var:string->list
mov rax, qword[fvar_tbl + WORD_SIZE*59 ]
push rax
; var:=
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
push 11
; lambda  set  set  set  set  set  set  set  set  set  set  set applicTP   lambda  set Boxset applicTP   lambda symbol:whatever

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode84)
jmp Lcont84
Lcode84:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+2)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+2)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+3)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+3)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+4)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+4)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+5)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+5)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+6)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+6)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+7)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+7)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+8)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+8)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+9)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+9)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+10)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+10)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda  set Boxset applicTP   lambda symbol:whatever
mov rax, const_tbl+23
push rax
push 1
; lambda  set Boxset applicTP   lambda

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode85)
jmp Lcont85
Lcode85:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
; lambda  set  set  if:  if: applic  then:applic  elsethen:applicTP  else if:  if: applic  then:applic  elsethen:applicTP  else if:  if: applic  then:applic  elsethen:applicTP  applic  applic  else if:  if: applic  then:applic  elsethen: applic  applic  applic  applicTP  applic  applic  else if:  if: applic  then:applic  elsethen:applicTP  applic  applic  elseapplicTP  

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode86)
jmp Lcont86
Lcode86:
push rbp
mov rbp, rsp

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+0)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

          MALLOC rbx, WORD_SIZE

          mov rcx , qword [rbp + WORD_SIZE*(4+1)]

          mov qword [rbx] , rcx

          mov rax , rbx

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
;applic  
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse88

                    ;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit88
 Lelse88:
                    ;applic  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
                        mov rax,qword[rax]
                        
mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 Lexit88:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse87

                    ;applicTP  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit87
 Lelse87:
                    ;applicTP  
mov rax, qword[rbp+8 * (4+1)]
                        mov rax,qword[rax]
                        
push rax
mov rax, qword[rbp+8 * (4+0)]
                        mov rax,qword[rax]
                        
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
                        mov rax,qword[rax]
                        
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit87:

leave
ret
Lcont86:


                              push rax

                              mov rax, qword[rbp+8 * (4+0)]
                              pop qword [rax]
                              mov rax, SOB_VOID_ADDRESS
;applicTP   lambda
push 0
; lambda

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode89)
jmp Lcont89
Lcode89:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
leave
ret
Lcont89:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont85:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont84:

mov rbx, rax
CLOSURE_ENV rax, rbx
push rax
CLOSURE_CODE rax, rbx
call rax
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*57], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, const_tbl+51
	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 ucomisd xmm0, xmm1
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
       .loop:
	 and rdi, rdi
	 jz .end_loop
	 xor rdx, rdx 
	 div rdi
	 mov rax, rdi
	 mov rdi, rdx
	 jmp .loop	
       .end_loop:
	 mov rdx, rax
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret