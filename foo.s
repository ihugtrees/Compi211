;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 69

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING whatever
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(-1,1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+61], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+60], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+3], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+4], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+5], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+6], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+7], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+9], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+10], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+11], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+12], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+13], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+14], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+15], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+36], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+17], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+18], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+20], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+22], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+21], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+35], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+47], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+43], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*23 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 5

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode1)
jmp Lcont1
Lcode1:
push rbp
mov rbp, rsp
mov rax, const_tbl+23
push rax
mov rax, const_tbl+23
push rax
push 2

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode2)
jmp Lcont2
Lcode2:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode3)
jmp Lcont3
Lcode3:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse4

                    mov rax, const_tbl+1
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit4
 Lelse4:
                    mov rax, const_tbl+1
 Lexit4:
leave
ret
Lcont3:

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode5)
jmp Lcont5
Lcode5:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse6

                    mov rax, const_tbl+1
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit6
 Lelse6:
                    mov rax, const_tbl+1
 Lexit6:
leave
ret
Lcont5:

                                              mov qword[rbp+8*(4+1)],rax
                                              mov rax, SOB_VOID_ADDRESS
push 0

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode7)
jmp Lcont7
Lcode7:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode8)
jmp Lcont8
Lcode8:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont8:

leave
ret
Lcont7:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont2:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont1:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*37], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void


CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode9)
jmp Lcont9
Lcode9:
push rbp
mov rbp, rsp
mov rax, const_tbl+1
push rax
mov rax, qword[rbp+8 * (4+2)]
push rax
push 2
mov rax, qword[fvar_tbl + WORD_SIZE*57 ]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse10

                    mov rax, qword[rbp+8 * (4+1)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit10
 Lelse10:
                    mov rax, qword[rbp+8 * (4+1)]
 Lexit10:
leave
ret
Lcont9:

              mov qword [fvar_tbl + WORD_SIZE*50], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void


CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode11)
jmp Lcont11
Lcode11:
push rbp
mov rbp, rsp
mov rax, const_tbl+1
push rax
mov rax, qword[rbp+8 * (4+2)]
push rax
push 2
mov rax, qword[fvar_tbl + WORD_SIZE*57 ]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse12

                    mov rax, qword[rbp+8 * (4+1)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit12
 Lelse12:
                    mov rax, qword[rbp+8 * (4+1)]
 Lexit12:
leave
ret
Lcont11:

              mov qword [fvar_tbl + WORD_SIZE*31], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void


CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode13)
jmp Lcont13
Lcode13:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse14

                    mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit14
 Lelse14:
                    mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit14:
leave
ret
Lcont13:

              mov qword [fvar_tbl + WORD_SIZE*29], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*23 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*31 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode15)
jmp Lcont15
Lcode15:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode16)
jmp Lcont16
Lcode16:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, const_tbl+1
push rax

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode17)
jmp Lcont17
Lcode17:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse18

                    mov rax, qword[rbp+8 * (4+0)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit18
 Lelse18:
                    mov rax, qword[rbp+8 * (4+0)]
 Lexit18:
leave
ret
Lcont17:

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 6
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont16:

leave
ret
Lcont15:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*30], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void


CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode19)
jmp Lcont19
Lcode19:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
leave
ret
Lcont19:

              mov qword [fvar_tbl + WORD_SIZE*32], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*3 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode20)
jmp Lcont20
Lcode20:
push rbp
mov rbp, rsp
mov rax, const_tbl+23
push rax
push 1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode21)
jmp Lcont21
Lcode21:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode22)
jmp Lcont22
Lcode22:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit23
    mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse24

                    mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[fvar_tbl + WORD_SIZE*33 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit24
 Lelse24:
                    mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[fvar_tbl + WORD_SIZE*33 ]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit24:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit23
    
Lexit23:
leave
ret
Lcont22:

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
push 0

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode25)
jmp Lcont25
Lcode25:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
leave
ret
Lcont25:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont21:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont20:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*33], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*12 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 3

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode26)
jmp Lcont26
Lcode26:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode27)
jmp Lcont27
Lcode27:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse28

                    mov rax, const_tbl+32
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit28
 Lelse28:
                    mov rax, const_tbl+32
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit28:
leave
ret
Lcont27:

leave
ret
Lcont26:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*12], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void


CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode29)
jmp Lcont29
Lcode29:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse30

                    mov rax, const_tbl+2
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit30
 Lelse30:
                    mov rax, const_tbl+2
 Lexit30:
leave
ret
Lcont29:

              mov qword [fvar_tbl + WORD_SIZE*42], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*20 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*17 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*37 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*36 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*60 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*61 ]
push rax
push 13

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode31)
jmp Lcont31
Lcode31:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode47)
jmp Lcont47
Lcode47:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode48)
jmp Lcont48
Lcode48:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse50

                    mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit50
 Lelse50:
                    mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 Lexit50:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse49

                    mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit49
 Lelse49:
                    mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit49:
leave
ret
Lcont48:

leave
ret
Lcont47:

push rax
push 1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode32)
jmp Lcont32
Lcode32:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode39)
jmp Lcont39
Lcode39:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse40

                    mov rax, qword[rbp+8 * (4+0)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit40
 Lelse40:
                    mov rax, qword[rbp+8 * (4+0)]
 Lexit40:
leave
ret
Lcont39:

push rax
push 1

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode33)
jmp Lcont33
Lcode33:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode34)
jmp Lcont34
Lcode34:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, const_tbl+34
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*5]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont34:

                                    mov qword[fvar_tbl + WORD_SIZE*17], rax
                                    mov rax, SOB_VOID_ADDRESS

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode35)
jmp Lcont35
Lcode35:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*6]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont35:

                                    mov qword[fvar_tbl + WORD_SIZE*18], rax
                                    mov rax, SOB_VOID_ADDRESS
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*7]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode36)
jmp Lcont36
Lcode36:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode37)
jmp Lcont37
Lcode37:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
                                        mov rax, qword[rbp+8*12]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse38

                    mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, const_tbl+51
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit38
 Lelse38:
                    mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, const_tbl+51
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit38:
leave
ret
Lcont37:

leave
ret
Lcont36:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

                                    mov qword[fvar_tbl + WORD_SIZE*20], rax
                                    mov rax, SOB_VOID_ADDRESS


leave
ret
Lcont33:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode42)
jmp Lcont42
Lcode42:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode43)
jmp Lcont43
Lcode43:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode44)
jmp Lcont44
Lcode44:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont44:

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*4]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, const_tbl+4
push rax

CREATE_EXT_ENV 4
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode45)
jmp Lcont45
Lcode45:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse46

                    mov rax, qword[rbp+8 * (4+1)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit46
 Lelse46:
                    mov rax, qword[rbp+8 * (4+1)]
 Lexit46:
leave
ret
Lcont45:

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 6
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont43:

leave
ret
Lcont42:

push rax
push 1

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode41)
jmp Lcont41
Lcode41:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*8]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8 * (4+0)]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

                                    mov qword[fvar_tbl + WORD_SIZE*22], rax
                                    mov rax, SOB_VOID_ADDRESS
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*9]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 1
mov rax, qword[rbp+8 * (4+0)]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

                                    mov qword[fvar_tbl + WORD_SIZE*21], rax
                                    mov rax, SOB_VOID_ADDRESS


leave
ret
Lcont41:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont32:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont31:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*17 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*28 ]
push rax
push 3

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode51)
jmp Lcont51
Lcode51:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode52)
jmp Lcont52
Lcode52:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse53

                    mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, const_tbl+68
push rax
push 2
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, const_tbl+34
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit53
 Lelse53:
                    mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, const_tbl+68
push rax
push 2
mov rax, qword[fvar_tbl + WORD_SIZE*18 ]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
mov rax, const_tbl+34
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit53:
leave
ret
Lcont52:

leave
ret
Lcont51:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*19], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*42 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
push 5

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode54)
jmp Lcont54
Lcode54:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode55)
jmp Lcont55
Lcode55:
ADJUST_LAMBDA_OPT_STACK 2
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, const_tbl+4
push rax

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode56)
jmp Lcont56
Lcode56:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse57

                    mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit59
    mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit59
    
Lexit59:
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit57
 Lelse57:
                    mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit58
    mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit58
    
Lexit58:
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit57:
leave
ret
Lcont56:

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*4]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 6
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont55:

leave
ret
Lcont54:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*41], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*4 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*43 ]
push rax
push 4

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode60)
jmp Lcont60
Lcode60:
push rbp
mov rbp, rsp
mov rax, const_tbl+23
push rax
push 1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode61)
jmp Lcont61
Lcode61:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode62)
jmp Lcont62
Lcode62:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse63

                    mov rax, qword[rbp+8 * (4+0)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit63
 Lelse63:
                    mov rax, qword[rbp+8 * (4+0)]
 Lexit63:
leave
ret
Lcont62:

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
push 0

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode64)
jmp Lcont64
Lcode64:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode65)
jmp Lcont65
Lcode65:
ADJUST_LAMBDA_OPT_STACK 1
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse66

                    mov rax, const_tbl+34
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit66
 Lelse66:
                    mov rax, const_tbl+34
 Lexit66:
leave
ret
Lcont65:

leave
ret
Lcont64:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont61:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont60:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*43], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
push 1

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode67)
jmp Lcont67
Lcode67:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode68)
jmp Lcont68
Lcode68:
push rbp
mov rbp, rsp
mov rax, const_tbl+34
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont68:

leave
ret
Lcont67:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*45], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*47 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*60 ]
push rax
push 3

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode69)
jmp Lcont69
Lcode69:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode70)
jmp Lcont70
Lcode70:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse71

                    mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit71
 Lelse71:
                    mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit71:
leave
ret
Lcont70:

leave
ret
Lcont69:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*2], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*60 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*61 ]
push rax
push 2

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode72)
jmp Lcont72
Lcode72:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode73)
jmp Lcont73
Lcode73:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit74
    mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit74
    
Lexit74:
leave
ret
Lcont73:

leave
ret
Lcont72:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*48], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*17 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*50 ]
push rax
push 2

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode75)
jmp Lcont75
Lcode75:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode76)
jmp Lcont76
Lcode76:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
mov rax, const_tbl+34
push rax

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode77)
jmp Lcont77
Lcode77:
push rbp
mov rbp, rsp
mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont77:

push rax
push 3
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 6
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont76:

leave
ret
Lcont75:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*49], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*23 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*19 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*21 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*9 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*10 ]
push rax
push 5

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode78)
jmp Lcont78
Lcode78:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode79)
jmp Lcont79
Lcode79:
push rbp
mov rbp, rsp
mov rax, const_tbl+23
push rax
push 1

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode80)
jmp Lcont80
Lcode80:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode81)
jmp Lcont81
Lcode81:
push rbp
mov rbp, rsp
mov rax, const_tbl+34
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse82

                    mov rax, qword[rbp+8 * (4+1)]
 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit82
 Lelse82:
                    mov rax, qword[rbp+8 * (4+1)]
 Lexit82:
leave
ret
Lcont81:

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
push 0

CREATE_EXT_ENV 3
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode83)
jmp Lcont83
Lcode83:
push rbp
mov rbp, rsp
mov rax, const_tbl+1
push rax
mov rax, const_tbl+51
push rax
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont83:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont80:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont79:

leave
ret
Lcont78:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*59], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, qword[fvar_tbl + WORD_SIZE*14 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*25 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*24 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*16 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*6 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*5 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*3 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*61 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*60 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*59 ]
push rax
mov rax, qword[fvar_tbl + WORD_SIZE*22 ]
push rax
push 11

CREATE_EXT_ENV 0
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode84)
jmp Lcont84
Lcode84:
push rbp
mov rbp, rsp
mov rax, const_tbl+23
push rax
push 1

CREATE_EXT_ENV 1
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode85)
jmp Lcont85
Lcode85:
push rbp
mov rbp, rsp

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode86)
jmp Lcont86
Lcode86:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8 * (4+0)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse88

                    mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit88
 Lelse88:
                    mov rax, qword[rbp+8 * (4+1)]
push rax
push 1
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

 Lexit88:
 cmp rax, SOB_FALSE_ADDRESS
 jne Lelse87

                    mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 cmp rax, SOB_FALSE_ADDRESS
 jne Lexit87
 Lelse87:
                    mov rax, qword[rbp+8 * (4+1)]
push rax
mov rax, qword[rbp+8 * (4+0)]
push rax
push 2
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*1]
                                        mov rax, qword[rbp+8*0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 5
CLOSURE_CODE rbx, rax
jmp rbx

 Lexit87:
leave
ret
Lcont86:

                                              mov qword[rbp+8*(4+0)],rax
                                              mov rax, SOB_VOID_ADDRESS
push 0

CREATE_EXT_ENV 2
mov rcx, rax
MAKE_CLOSURE(rax, rcx, Lcode89)
jmp Lcont89
Lcode89:
push rbp
mov rbp, rsp
mov rax, qword[rbp+8*2]
                                        mov rax, qword[rbp+8*0]
                                        mov rax, qword[rbp+8*0]
leave
ret
Lcont89:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 3
CLOSURE_CODE rbx, rax
jmp rbx


leave
ret
Lcont85:

CLOSURE_ENV rbx, rax
push rbx
push qword[rbp+8*1]   ;old ret addr
FIX_APPLICTP_STACK 4
CLOSURE_CODE rbx, rax
jmp rbx

leave
ret
Lcont84:

CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8*1 ;pop env
pop rbx      ;pop arg count
shl rbx, 3   ;rbx = rbx*8
add rsp, rbx ;pop args

              mov qword [fvar_tbl + WORD_SIZE*57], rax
              mov rax, SOB_VOID_ADDRESS

          
	call write_sob_if_not_void

mov rax, const_tbl+51
	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 ucomisd xmm0, xmm1
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
       .loop:
	 and rdi, rdi
	 jz .end_loop
	 xor rdx, rdx 
	 div rdi
	 mov rax, rdi
	 mov rdi, rdx
	 jmp .loop	
       .end_loop:
	 mov rdx, rax
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret